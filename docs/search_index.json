[
["index.html", "Vehicular emissions inventory with VEIN Preface Purpose Structure About the author", " Vehicular emissions inventory with VEIN Sergio Ibarra-Espinosa 2018-11-12 Preface This book is about the process for estimating vehicular emissions. This process is complex and can be dificult. It is required a big amount of information related to traffic, emissions factors and then process the outpus for the desired purpose. In this book this process is addressed with the VEIN (S. Ibarra-Espinosa et al. 2018) model, which is an R package available at https://CRAN.R-project.org/package=vein}. Purpose I wrote this book to provide instructions to all possible users who want to estimate vehicular emissions using VEIN. VEIN provides several function which are related to each other reading different traffic sources and emission factors for different pollutants. However, incorporating all the functions with input/output (I/O) process can be difficult. Moreover, communicating the recommended practices and instructions to a increasingly broader audience can be more difficult. Therefore, the purpose of this book is to reach the maximum amount of interested people in a simple way. The language chosen is engligh because it is the global language. Structure Chapter 1 covers the introduction to this book including the installation of R packages and dependent libraries to several operative systems. Chapter 2 covers basics commands using R. Chapter 3 presents the function inventory to produce an structure of directories and scripts for runnin vein. Chapter 4 covers the required traffic data for inputting into VEIN including differenttypes and sources of information. Chapter 5 includes the emission factors that are included into the package and also, examples for inputing and creating new emission factors. Chapter 6 presents the estimations functions and tips. Chapter 7 includes the functions to do post-estimations to generate emission data-bases and also emissions at each street. Chapter 8 and 9 provides applications into air quality modeling, some studies with to investigte health effects and lastly, the use of VEIN as a tool for environmental planning. About the author Sergio Ibarra Espinosa is a chilean Environmental and Loss Prevention Engineer from the Technologycal Metropolitan University (UTEM) where study the health effects of air pollution using R in year 2007. Then started working at the National Center for Environment (CENMA) in Chile focused on emissions from vehicles, airports, biomass burning and minning industry. Then obtained a MSc. in Environmental Planning and Managment from the University of Chile, with a scholarship form CENMA. Then obtained a PhD. in Meteorology at the Institute of Astronomy, Geophysics and Atmospheric Sciences (IAG) from the University of São Paulo (USP) with scholarship from CAPEs during the first year and Becas Chile for the last three years. During his PhD. he learned programming with R and developed the R package VEIN. Appendix B "],
["intro.html", "Chapter 1 Introduction 1.1 Definitions and sources of information 1.2 Installation 1.3 Required R packages and dependencies 1.4 Data inside the VEIN model 1.5 Acknowledgements", " Chapter 1 Introduction 1.1 Definitions and sources of information Developing emissions inventories is a complex task. Therefore, before entering into the details of the functions, it is good to provide some initial definitions. A good starting point is the book “The Art of Emissions Inventorying” (Pulles and Heslinga 2010). This book provides general description of what is an emissions inventory. One of the early sources of information about emissions inventories and emissions factors is the Environmental Protection Agency (U.S.EPA) and its compilation of emission factors AP42 (https://www.epa.gov/air-emissions-factors-and-quantification). A third source of information are the European EMEP/EEA air pollutant emission inventory guidebook (https://www.eea.europa.eu/themes/air/emep-eea-air-pollutant-emission-inventory-guidebook/). An emissions inventory is the compilation of all mass emitted into the atmosphere by activities in a defined area during a lapse of time. The Eq. ((1.1) shows the general form (McGlade and Vidic 2009): \\[\\begin{equation} Emission_{pollutant}=\\sum_{activities} Activity reate \\cdot Emission factor_{activity, pollutant} \\tag{1.1} \\end{equation}\\] There are two main types of inventories based on the application, one type is for policy application and the other for scientific application (Pulles and Heslinga 2010). Inventories for policy application include the National Greenhouse Gas Inventory for the parties under the United Nations Framework on Climate Change (UNFCCC 2017). Emissions inventories with scientific applications include the Emission Database for Global Atmospheric Research EDGAR (EJ-JRC/PBL 2016). Emissions inventories can be also multimedia inventories, such as the Pollutant Release and Transfer Registers (PRTR) which include pollutants released to air, water and soil and transferred off-site for treatment or disposal (http://www.oecd.org/chemicalsafety/pollutant-release-transfer-register/). However, the type of inventory covered in this book cover only the emissions released into the atmosphere. 1.1.1 Approaches It is necessary show some definitions of vehicular emissions inventories approaches, which in this case comes from the European Emissions Guidelines (Ntziachristos and Samaras 2016): Top-down inventories are using input activity traffic data as fleet statistics, fuel consumption, representative speeds and country balances. The emissions factors are based on representative speeds. These inventories are also know as static. Bottom-up invetories are using input activity traffic data from traffic counts, traffic simulations, vehicle composition, speed recordings and length of roads. The emission factors are speed or/and acceleration functions. These inventories are also know as dynamic. Reconciliation Both approaches can be reconciliated in urban emissions inventories with comparison of total mileage, cold start mileage or emission factors to ensure that the comparison with the total fuel consumption in the study area is satisfactory. This means that bottom-up and top-down vehicular emissions must match the fuel sales over a region of study. 1.2 Installation The VEIN r-package can be installed from Comprehensive R Archive Network CRAN directly: # CRAN install.packages(&quot;vein&quot;) VEIN can be also installed from github: library(devtools) install_github(&quot;ibarraespinosa/vein&quot;) The github installation requires that the devtools package (Wickham and Chang 2017) must be installed, including its dependencies. 1.3 Required R packages and dependencies VEIN improts functions from other R packages. HEnce, these packages are necessary:: sf is a package that provides simple features access for R (Pebesma 2017). It depends on the library GEOS (http://trac.osgeo.org/geos), ‘Geospatial’ Data Abstraction Library (‘GDAL’) (http://www.gdal.org/) and PROJ (http://proj4.org/). data.table is a package that provides simple features access for R (Pebesma 2017). It can be installed. - sp. This is a package that provides classes and methods for spatial data (Pebesma and Bivand 2005) considering points, lines, polygons and grids. few function of sp are imported, most of them comes from sf. eixport is a package (Ibarra-Espinosa, Schuch, and de Freitas 2017) that creates inputs for atmospheric models (Ibarra-Espinosa, Schuch, and Dias de Freitas 2018). - units. It is a package for measurement units in R (Pebesma, Mailund, and Hiebert 2016). This package depends on the library udunits2 (http://www.unidata.ucar.edu/software/udunits/). I install.packages(c(&quot;sf&quot;, &quot;data.table&quot;, &quot;sp&quot;, &quot;eixport&quot;, &quot;units&quot;)) In order to install sf package it is necessary to install the dependencies into each operational system. Ubuntu sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable sudo apt-get update sudo apt-get install libudunits2-dev libgdal-dev libgeos-dev libproj-dev Fedora sudo dnf install gdal-devel proj-devel proj-epsg proj-nad geos-devel udunits2-devel Debian and other Dockerfiles from rocker geospatial. Windows Via Rtools. MAC OS brew unlink gdal brew tap osgeo/osgeo4mac &amp;&amp; brew tap --repair brew install proj brew install geos brew install udunits brew install gdal2 --with-armadillo --with-complete --with-libkml --with-unsupported brew link --force gdal2 The R package eixport imports function from ncdf4 (Pierce 2017), therefore the library NetCDF must be installed. For Ubuntu, do: sudo apt install libnetcdf-dev netcdf-bin 1.4 Data inside the VEIN model There are several datasets available inside the model: 1.4.1 Emission factors from CETESB fe2015: Emission factors from the Environmental Agency of Sao Paulo (CETESB). Pollutants included: “CH4”, “CO”, “CO2”, “HC”, “N2O”, “NMHC”, “NOx” and “PM”. The type of vehicles included are Passenger Cars (PC). usage: library(vein, quietly = T) data(fe2015) Table 1.1: Emission factors from CETESB in VEIN model Age Year Pollutant PC_G LT 1 2015 CO 0.171 0.027 2 2014 CO 0.216 0.012 3 2013 CO 0.237 0.012 4 2012 CO 0.273 0.005 5 2011 CO 0.275 0.379 6 2010 CO 0.204 0.416 1.4.2 Mileage functions of Brazilian Fleet fkm: A list of functions of mileage in km for the Brazilian fleet. It includes mileage functions based on more than 2 million recordings of vehicles (Bruni and Bales 2013). It consists a list of age functions. The type of vehicles are Passneger Cars (PC), Light Commercial Vehicles (LCV), Small Busses (SBUS), Trucks, Articulated Trucks (ATRUCKS), Motorcycles (MOTO) and Light vehicles (LDV). The fuels are Gasoline using 25% of ethanol (E25), Ethanol 100% (E100) and Diesel with 5% of biodiesel (B5). There are also vehicles with flex engines which can run either with E25, E100 or any mixture in between (Giroldo et al. 2005). The Fig. (1.1 shows the mileage of PC using fuel E25. usage: library(vein, quietly = T) data(fkm) names(fkm) ## [1] &quot;KM_PC_E25&quot; &quot;KM_PC_E100&quot; &quot;KM_PC_FLEX&quot; &quot;KM_LCV_E25&quot; ## [5] &quot;KM_LCV_FLEX&quot; &quot;KM_PC_B5&quot; &quot;KM_TRUCKS_B5&quot; &quot;KM_BUS_B5&quot; ## [9] &quot;KM_LCV_B5&quot; &quot;KM_SBUS_B5&quot; &quot;KM_ATRUCKS_B5&quot; &quot;KM_MOTO_E25&quot; ## [13] &quot;KM_LDV_GNV&quot; age &lt;- 1:50 mileage &lt;- fkm[[&quot;KM_PC_E25&quot;]](1:50) par(mar = c(4, 4, .1, .1)) plot(y = mileage, x = age, pch = 19, type = &quot;b&quot;) Figure 1.1: Mileage of PC using E25 net: Road network of the west part of Sao Paulo city. It consistes in a SpatialLinesDataFrame (class of sp) with the attributes ldv (light duty vehicles, \\(1 \\cdot h^{-1}\\)), hdv (heavy duty vehicles, \\(1 \\cdot h^{-1}\\)), ps (peak speed, \\(km \\cdot h^{-1}\\)), ffs (free flow speed, \\(km \\cdot h^{-1}\\)), tstreet (type of street), lanes (number of lanes), capacity (capacity fo vehicles at each link, 1/h) and tmin (time for travelling each link, min). The Fig. (4 shows more details. 1.4.3 Temporal factors for Passenger Cars Temporal factors (TF) are marix of jourly traffic data normalized for the hour of interest, normally the morning rush hour 08:00-09:00 in local time (LT) (S. Ibarra-Espinosa et al. 2018). This dataset cover 168 hours of one week and it is based on traffic counts of toll stations near the center of the city of SãoPaulo, Brazil. The Fig. (1.2 shows the temporal factors for PC. usage: library(vein, quietly = T) data(pc_profile) tf &lt;- unlist(pc_profile) hours &lt;- 1:168 par(mar = c(4, 4, .1, .1)) plot(y = tf, x = hours, pch = 16, type = &quot;b&quot;) Figure 1.2: Temporal Factors for PC 1.4.4 Profile for cold starts of Passenger Cars This is a profile with the hourly percentage of cold starts of Passenger Cars. This data covers 24 hours of a working day and it is based cold start recordings during the implementation of the International Vehicle Emissions (IVE) model (Davis et al. 2005) in São Paulo (Lents et al. 2004). The Fig. (1.3 shows the cold-start profile. usage: library(vein, quietly = T) data(pc_cold) cold &lt;- unlist(pc_cold) hours &lt;- 1:24 par(mar = c(4, 4, .1, .1)) plot(y = cold, x = hours, pch = 16, type = &quot;b&quot;) Figure 1.3: Cold-starts profile for PC 1.5 Acknowledgements Martin Ramacher, PhD Student Chemistry Transport Modelling, Institute for Coastal Research, Helmholtz-Zentrum Geesthacht, Germany - Proofreading. Leila Droprinchinski Martins, Professor (Associate) Federal Technological University of Parana, Brazil - Comments. Appendix B "],
["basic.html", "Chapter 2 Basics of R 2.1 Brief history 2.2 Using R 2.3 Inputting data into R", " Chapter 2 Basics of R 2.1 Brief history R is a programming language developed by Ross Ihaka and Robert Genleman in 1993 (Ihaka and Gentleman 1996). A good resource about R is the book “Programming for data science” (Peng 2015). R can be explained as a free version of S-PLUS programming language (http://www.solutionmetrics.com.au/products/splus/default.html). It is free and recognized as GNU software (https://www.gnu.org/software/software.html) with GNU General Public License (GPLV2-GPLV3) license. This feature allowed that many developers started improving and adding code over the years. R includes several statistical functions, therefore, users who just want to use the base capabilities of R are not forced to learn R-programming. However, the evolution from user to developer in R has been facilitated with numerous publications such as the book “R packages: organize, test, document, and share your code” (Wickham 2015), or “The art of R programming: A tour of statistical software design” (Matloff 2011). 2.1.1 Installation R can be installed in different OS including Linux, Windows, Mac and Solaris. The webpage https://cran.r-project.org/ shows how to install R in any platform. A popular Integrated development environment (IDE) is RStudio https://www.rstudio.com/, which contains many useful integrated options. However, R can be run on the terminal and any any text editor can be used to write scripts in R. 2.2 Using R If we type at the R promt x &lt;- 1 # Not printing results x # Print results ## [1] 1 print(x) # Explicit print x ## [1] 1 The integer 1 was assigned (&lt;-) to x, then writing x or print(x) will show the value of x. Instead of numbers, other expressions such as strings, dates or other objects can be assigned. R includes several statistical functions. For instance, if we type ‘pi’ at the terminal, it will print the pi number. pi ## [1] 3.141593 2.2.1 R objects There are five basic classes (or atomic classes). character. numeric. integer. complex. logical (TRUE/FALSE or just T or F). Objects of the same class can be grouped in vectors. Vectors are created with writing c() with the elements of the vector inside the parenthesis, separated by colon. In fact, c is a built-in function to create vectors. In this case, the vector v1 contains a sequence of three integers, from 1 to 3. The resulting class is numeric. v1 &lt;- 1:3 v2 &lt;- c(1, 2, 3) identical(v1, v2) ## [1] FALSE v1 ## [1] 1 2 3 class(v1) ## [1] &quot;integer&quot; With the operator [ we can get specific elements of your vectors. In the following code the function length is used additionally, which simply returns the length of an object. v1[1] # first element of v1 ## [1] 1 v1[length(v1)] # last element element of v1 ## [1] 3 If we create a vector with numbers and letter, the resulting vector will be “character”, automatically converting the numbers into characters. v2 &lt;- c(1:3,&quot;a&quot;) v2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; class(v2) ## [1] &quot;character&quot; Objects can be converted to other classes with the as.* functions. For instance, if we convert the vector v2 to numeric, it will recognize the numbers adding an NA into the position of the character. as.numeric(v2) ## Warning: NAs introduzidos por coerção ## [1] 1 2 3 NA 2.2.2 Factors Factors represents categorical data. A typical example is a character vector of days of the week. The function factor creates factors. To see the help section, type ?factor. The following example will use this function with the arguments x and levels. dow &lt;- factor(x = c(&quot;Wednesday&quot;, &quot;Monday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;), levels = c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;)) dow ## [1] Wednesday Monday Thursday Friday ## Levels: Monday Tuesday Wednesday Thursday Friday 2.2.3 Missing Values Missing values in data-sets are a typical source of headache for R users. Fortunatly, R counts with several tools to avoid these headaches. These tools are fhe functions is.na to check for NA (not available) and is.nan (not a number). This functions returns logical values. n &lt;- c(1, NA) is.na(n) ## [1] FALSE TRUE n &lt;- c(1, NaN) is.na(n) ## [1] FALSE TRUE is.nan(n) ## [1] FALSE TRUE 2.2.4 Matrices Matrices are structure with rows and columns. They can be created using the matrix function and also, using vectors. Remember, if you want to know more about any function you just have to type ? and the function (e.g. ?matrix) and the help documentation for the function matrix will be opened. Let’s create a matrix using vectors: a &lt;- 1:12 #numeric vector (m &lt;- matrix(data = a, nrow = 3, ncol = 4)) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 We can check the dimensions of our matrix m with dim, which are 3 and 4. dim(m) ## [1] 3 4 In order to get the elements of matrix m we can use the [ operator: m[1, 1] # first element ## [1] 1 m[, 1] # firs column ## [1] 1 2 3 m[1, ] # firs row ## [1] 1 4 7 10 m[3,4] # last element ## [1] 12 2.2.5 Arrays Arrays are like matrices inside other matrices. In fact, a matrix is a 2-dimensional array. Let’s create an array create an array using the same vector a and same dimensiones of m, 3 and 4. array has three arguments, data, dim and dimnames. In the argument dim let’s add the number 2, resulting in an array of two matrices identical to m. (a &lt;- array(data = a, dim = c(3,4,2))) ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 We can subset elements from array also with the [ operator. a[1, 1, 1] # first element ## [1] 1 dim(a) # dimensions ## [1] 3 4 2 a[3, 4, 2] # last element ## [1] 12 2.2.6 Lists List are objects that can contain elements of different classes. I like to call lists as bags. In a bag you can put almost anything. Also, inside the bag, you can put other bags with different things. This means that you can have a list of lists of any R object. Lists can be created with the list function. Let’s create an empty list. Then we will use the vecctor a to create another list. a &lt;- 1:3 # vector of three elements l1 &lt;- list() # empty list l1 &lt;- list(a) # vector of three elements length(l1) # length 1 ## [1] 1 l1 &lt;- as.list(a) # vector a as list length(l1) # three elements ## [1] 3 As mentioned, the list can have lists inside. l1 &lt;- list(list(a), # three numeric elements list(TRUE, TRUE, FALSE)) # three logical elements length(l1) # length 2 ## [1] 2 2.2.7 Data-Frames “Data-frames are used to store tabular data in R” (Peng 2015). You can think of data-frames as spreadsheet-like objects. They are similar to matrices and you can have a matrix and a data-frame with the same dimensions. Basically, you have rows and columns, columns can have different classes, and the columns usually have a one-word name. As this type of object is very used by scientists, there are R packages created to work with this type of ojects. Below some of them: data.frame: This is not a package. It is a class and function from the base library in R. With this function you can create data-frames. data-table (Dowle and Srinivasan 2017): data.tables objects has the class data.table which inherits from the class data-frame, which means that they share common characteristics. However, the big difference with data-table is the efficiency with memory. It includes functions such as fread for reading millions of observations in seconds. tidyr(Wickham and Henry 2018): Sometimes your data is in long format and you need it in wide format, and viceversa. This package does the job. readxl (Wickham and Bryan 2017): Good package for importing Excel and LibreOffice files. I recommend this packages for newbies. sf (Pebesma 2017): This package presents the class sf and introduces the list-column of spatial geometry. Let’s create a data-frame. a &lt;- 1:3 b &lt;- 3:5 (ab &lt;- data.frame(a, b)) ## a b ## 1 1 3 ## 2 2 4 ## 3 3 5 class(ab) ## [1] &quot;data.frame&quot; 2.2.8 Names In R you can put names in almost everything. Below examples for vectors, matrix and data.frames. names(ab) # original names ## [1] &quot;a&quot; &quot;b&quot; names(ab) &lt;- c(&quot;c&quot;, &quot;d&quot;) names(ab) # new names ## [1] &quot;c&quot; &quot;d&quot; 2.3 Inputting data into R Your data can be in different formats. In this section I will show you how you can input text and comma separated value files, which is a very common task. Let’s say that you are using a spreadsheet program such as Microsoft Excel or LibreOffice. Then you might want to import your data into R. Your first check is, if the first row of your data has a name or not. If they do have names, this means that they have a header. Then click on ‘Save as’ and search text file with extension .txt or .csv. Then you edit your file with a notepad (e.g. bloc, gedit, vi or other tool) to check if the decimal character is point ‘.’ and the separator character is comma ‘,’ or semicolon ‘;’ or another character. This depends on the regional configuration of your spreadsheet software. If your file has the extension ‘.txt’, use read.table and if it is ‘.csv’, use read.csv. Once you checked the format, you can import your ‘.txt’ or ‘.csv’ files in R: a &lt;- read.csv(&quot;path/to/file.csv&quot;, sep = &quot;,&quot;, header = T) a &lt;- read.tablesv(&quot;path/to/file.txt&quot;, sep = &quot;,&quot;, header = T) Appendix B "],
["st.html", "Chapter 3 Structuring an Emissions Inventory 3.1 Overview of emissions inventorying using VEIN 3.2 The inventory function", " Chapter 3 Structuring an Emissions Inventory The elaboration of vehicular emissions inventories in vein, consists of four stages: pre-processing activity data, preparing emissions factors, estimating the emissions and post-processing of emissions in maps and databases. This means that vein provides functions to be used in each of the stages. However, in order to follow these stages, a structure of directories with scripts including vein functions is necessary. Therefore, the vein function inventory was created to create this structure of directories. 3.1 Overview of emissions inventorying using VEIN Figure 3.1: Structuring an emissions inventories with VEIN 3.2 The inventory function The inventory function creates creates a structure of directories and scripts to run vein. This structure is a suggestion and the user can use any other. The following code shows the arguments of the function. This is done using the base function args with inventory. args(inventory) ## function (name, vehcomp = c(PC = 1, LCV = 1, HGV = 1, BUS = 1, ## MC = 1), scripts = TRUE, show.dir = TRUE, show.scripts = FALSE, ## clear = TRUE, rush.hour = FALSE) ## NULL The arguments are name, vehcomp, scripts, show.dir, show.scripts and clear. The argument name The argument name is a word to be used as main directory where directories and scripts are stored in. It consists in one word with ascii characters. It is also recommended to be used without any special character or accents, for instance: name = file.path(tempdir(), &quot;YourCity&quot;) inventory(name = name, show.dir = TRUE, show.scripts = TRUE) The argument vehcomp This argument is very important and comes from Vehicular Composition, which is the classification of the fleet by type of use, type of fuel, size of engine and gross weight, based on definitions of Corvalán, Osses, and Urrutia (2002). There is also the technological composition of the fleet which relates the technological modifications of the car in order to accomplish the emissions standards. However, vein uses a distribution by age of use as 4 shows. The vehicular composition vehcomp has 5 types of vehicles: Passenger Carss (PC). Light Commercial Vehicles (LCV). Heavy Good Vehicles or trucks (HGV). Buses (BUS). Motorcycles (MC). The default value of this argument is: c(PC = 1, LCV = 1, HGV = 1, BUS = 1, MC = 1), which means that there are 1 types of PC, 1 of LCV, 1 of trucks, 1 of buses and 1 types of motorcycles. This vehicular composition is only for ilutrasting that the user can change these values according to its own data. Appendix B shows the vehicular composition from the vehicular emissions inventory of the Environmental Agency of São Paulo, Brazil (CETESB 2015). In Brazil, the fuel used in vehicles is blended with ethanol with and biodiesel. The user can use any vehicular composition that representes its fleet with up-to 99 types of vehicles per category. For instance, if there are 4 types of PC in a fleet, PC = 4, and each one has aa age of use distribution. The argument show.dir This is a logical argument to decide if the output of the function will return print the new directories or not. The use is: name = file.path(tempdir(), &quot;YourCity&quot;) inventory(name = name, show.dir = TRUE, show.scripts = FALSE) ## files at /tmp/RtmpAxG1On/YourCity ## Directories: ## [1] &quot;/tmp/RtmpAxG1On/YourCity&quot; ## [2] &quot;/tmp/RtmpAxG1On/YourCity/ef&quot; ## [3] &quot;/tmp/RtmpAxG1On/YourCity/emi&quot; ## [4] &quot;/tmp/RtmpAxG1On/YourCity/emi/BUS_01&quot; ## [5] &quot;/tmp/RtmpAxG1On/YourCity/emi/HGV_01&quot; ## [6] &quot;/tmp/RtmpAxG1On/YourCity/emi/LCV_01&quot; ## [7] &quot;/tmp/RtmpAxG1On/YourCity/emi/MC_01&quot; ## [8] &quot;/tmp/RtmpAxG1On/YourCity/emi/PC_01&quot; ## [9] &quot;/tmp/RtmpAxG1On/YourCity/est&quot; ## [10] &quot;/tmp/RtmpAxG1On/YourCity/images&quot; ## [11] &quot;/tmp/RtmpAxG1On/YourCity/network&quot; ## [12] &quot;/tmp/RtmpAxG1On/YourCity/post&quot; ## [13] &quot;/tmp/RtmpAxG1On/YourCity/post/df&quot; ## [14] &quot;/tmp/RtmpAxG1On/YourCity/post/grids&quot; ## [15] &quot;/tmp/RtmpAxG1On/YourCity/post/streets&quot; ## [16] &quot;/tmp/RtmpAxG1On/YourCity/profiles&quot; ## [17] &quot;/tmp/RtmpAxG1On/YourCity/veh&quot; inventory creates the direcrory “YourCity” and the sub directories: daily, ef, emi, est, images, network and veh. daily: Directory for storing the profiles saved as .csv files. For instance, data(pc_profile) is a matrix that could be saved as .csv. ef: Directory for storing the emission factors data-frame, similar to data(fe2015) but including one column for each of the categories of the vehicular composition. For instance, if PC = 5, there should be 5 columns with emission factors in this file. If LCV = 5, another 5 columns should be present, and so on. emi: Directory with subdirectories matching the vehicular composition for saving the estimates. It is suggested to use .rds extension instead of .rda. est: Directory with subdirectories matching the vehicular composition for storing the scripts named input.R. images: Directory for saving images. network: Directory for saving the road network with the required attributes. This file will include the vehicular flow per street to be used by functions age_ldv, age_hdv, age_moto or my_ldv. post: Directory for storing the processed emissions. It includes the directories df for emissions by age of use, hour and other parameters, streets for storing the total emissions by streets and grids for storing total gridded emissions by pollutant. veh: Directory for storing the distribution by age of use of each category of the vehicular composition. Those are data-frames with number of columns with the age distribution and the number of rows as the number of streets. The class of these objects is “Vehicles”. The argument scripts This argument adds scripts into the directories. The default is TRUE. The type of scrits create are: main.R: Adds the setwd(&quot;YourCity&quot;), library(vein), source(traffic.R), some comments and a loop to source all inputs. It is recommended not using the loop till it is certain that all scripts are correct. traffic.R: Includes two lines with exampmles of how to use the age_ldv function and saving the output in the directory veh. input.R: Each file has the scripts for reading the network, vehicles, emission factors and estimating emissions. The argument show.scripts This argument prints the scripts created: name = file.path(tempdir(), &quot;YourCity&quot;) inventory(name = name, show.dir = FALSE, show.scripts = TRUE) ## files at /tmp/RtmpAxG1On/YourCity ## Scripts: ## [1] &quot;est/BUS_01_input.R&quot; &quot;est/HGV_01_input.R&quot; &quot;est/LCV_01_input.R&quot; ## [4] &quot;est/MC_01_input.R&quot; &quot;est/PC_01_input.R&quot; &quot;main.R&quot; ## [7] &quot;post.R&quot; &quot;traffic.R&quot; The argument clear This is a logical argument that deletes recursively when TRUE, or not when FALSE, the directory and creates another one. Default is TRUE. The following chapters show the use of other vein functions inside an structure of directories and scripts with the name inventory(&quot;YourCity&quot;). Appendix B "],
["traffic.html", "Chapter 4 Traffic data 4.1 Sources of traffic data 4.2 Main functions 4.3 Vehicular composition 4.4 Application", " Chapter 4 Traffic data Traffic data is read in VEIN as spatial information. In other words, traffic data must be in any vectorial line spatial format with the drivers provided by the library GDAL (http://www.gdal.org/ogr_formats.html), which is called by the packages rgdal or sf. This means that traffic data must be in in any GDAL spatial format. The Eq. (4.1) shows how traffic data is treated in VEIN. \\[\\begin{equation} F^*_{i,j,k} = Q_{i} \\cdot VC_{i,j} \\cdot Age_{j,k} \\tag{4.1} \\end{equation}\\] where \\(F^*_{i,j,k}\\) is the vehicular flow at street link \\(i\\) for vehicle type \\(j\\) by age of use \\(k\\). \\(j\\) defines the vehicular composition according to its type of use, type of fuel, size of engine and gross weight, based on definitions of (Corvalán, Osses, and Urrutia 2002). \\(Q_i\\) is the traffic flow at street link \\(i\\). \\(VC_{i,j}\\) is the fraction of vehicles varying according to the type of vehicles \\(j\\) in the vehicle fleet at street link \\(i\\). \\(Age_{j,k}\\) is the age distribution by vehicular composition \\(j\\) and age of use \\(k\\). This Equation shows that \\(VC\\) splits the total vehicular flow \\(Q\\) to identify the vehicular fraction, which varies according to the type of fuel, size of motor and gross weight. For example, if \\(Q\\) is light duty vehicles (LDV) and it is known that 5% of the \\(Q\\) are passenger cars (PC), with engines lesser than 1400 cc, \\(VC\\) is 0.05. This characterization of the fleet depends on the amount and quality of the available information. VEIN then multiplies the traffic with \\(Age\\) to obtain the amount of each type of vehicle by age of use. 4.1 Sources of traffic data 4.1.1 Travel demand outputs VEIN was developepd according to the available traffic data in São Pauo, Brazil. In this case, the available data was a 4-stage macroscopic travel model for morning rush hours and hourly traffic counts for morning and evening rush hours. The travel model is based on data from an Origin-Destination-Survey (ODS) (Metro 2017) which started in the decade of 1950 in São Paulo. A classic reference of a 4-stage modeling transport is (Ortuzar and Willumsen 2002). The 4 stages of the traffic modeling include characterization of trip attractions and productions by zone in some regions, distribution of these trips, the preferred mode of transport for traveling and finally the allocation of the trips at each mode; in this case into the road network. The ODS is made every 10 years by Metro (http://www.metro.sp.gov.br/), which is the underground company, and they perform a smaller update of ODS after 5 years. The information gathered in the ODS is massive due to participation of thousands of commuters. It helps to identify characteristics of the trips inside MASP. CET uses the information from ODS and performs the traffic simulation. In this case, it is a macro or strategic traffic simulation which represents the equilibrium between offer and supply of transportation at maximum load of the road network, that is, at the rush hour, which is from 08:00 to 09:00 Local Time (LT). VEIN incorporates an extract of a traffic model simulation for the west part of São Paulo named net. The Fig. (4.1 shows the traffic of Light Duty Vehicles (LDV). This data covers the surrounding area of the University of São Paulo. The information obtained from CET consists in: ldv: Light Duty Vehicles (1/h). hdv: Heavy Duty Vehicles (1/h). lkm: Length of the link (km). ps: Peak Speed (km/h). ffs: Free Flow Speed (km/h). tstreet: Type of street. lanes: Number of lanes per link. capacity: Capacity of vehicles in each link (1/h). tmin: Time for travelling each link (min). The following scripts show how to load this data in R. This data has the class “SpatialLinesDataFrame” from the package (Pebesma and Bivand 2005). This data was converted into an spatial feature “sf” object (Pebesma 2017) because it consists of a data-frame with a list-column of geometry with the spatial attributes and it is easier to handle than an sp object class. As mentioned, future versions of VEIN will migrate to sf. The user must call the library VEIN first, then load the data net. The object net has the class “SpatialLinesDataFrame”. This data can be loaded and shown in R like this: library(vein) library(sp) data(net) class(net) ## [1] &quot;SpatialLinesDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; The Fig. (4.1) shows that traffic is concentrated in main streets such as the motorway Marginal Pinheiros, located in the north east part of the area. library(vein) data(net) net$ldv &lt;- as.numeric(net$ldv) spplot(net, &quot;ldv&quot;, scales = list(draw = T), col.regions = rev(bpy.colors(16))) Figure 4.1: LDV at 08:00-09:00 (LT) in west São Paulo 4.1.2 Inteprolation of traffic counts Travel model simulations are not always available and the user interested in estimating vehicular emisisons with a bottom-up approach would have to look for alternatives to obtain traffic data at street level. These alternatives cover interpolating traffic data for different temporal resolutions. For instance, Réquia Jr, Koutrakis, and Roig (2015) developed a vehicular bottom-up inventory using traffic counts and a geostatistic method called Global Moran’s I test (Anselin 1995). It measures the spatial autocorrelation. However, this technique requires that the observed values are normal, which is not the case for count data. Other authors were instested in predicting Anual Average Daily Traffic (AADT) or only ADT. Lowry (2014) presented a new method for predicting AADT based on the concept of origin-destination centrality. The idea is to obtain predictor variables directly from the road network. He identified origin and destination zones and added multiplication factors based on the land-use characteristics. Zhao and Chung (2001) tested several multiple stepwise regressions incorporating land-use characteristics. They considered several variables: number of lanes, classificatiion of road type, employment numbers and access to expressway with correlations between 0.66 and 0.82. Lam and Xu (2000) compared neural networks and regressions for a dataset of 13 locations. Kriging methods were used in AADT interpolation by Eom et al. (2006), who predicted AADT for non-motorway streets. Also, Selby and Kockelman (2013) compared Kriging and geographically weighted regressions in the prediction of AADT. Another approach is to perform a spatial regression based on the distributio on the observed data. As the data is counts of traffic, a poisson, quasi-poisson or negative binomial regressions can be used (Zeileis, Kleiber, and Jackman 2008). Recently, Sergio Ibarra-Espinosa, O’Sullivan, et al. (2017) compared quasi-poisson and negative binomial regresions predicting hourly traffic data, with better results for a quasi-poisson approach (correlation of 0.72). Newer approaches involve GPS data from smartphones and cars. 4.1.3 Generating traffic flows from Origin-Destination-Surveys (ODS) The origin destination survey (ODS) is an important tool which quantifies the amount of trips generated in the study area. ODS studies started decades ago. The oldest ODS paper on Google Scholar is entitles “FUNCTIONS OF A HIGHWAY-PLANNING SURVEY DEPARTMENT” by W. J. Sapp in 1938 at the TWENTY-FOURTH ANNUAL ROAD SCHOOL (Sapp 1938). In this paper the importance of information for the traffic engineer is discussed: “The engineer must have the supporting data available to substantiate his decisions.” Another study of 1942 shows the importance of traffic counts, disucssing the elaboration of an origin destination survey where 8000 Boy Scouts of America participated in counting traffic. The method for analyzing the data consisted in counting the vehicles identifying the licence plate in order to determine the origin (the first time the vehicle was recorded), the route of vehicles, the destination and the approximate time for the trip. After those pioneer studies many many other studies went deeper into the subject. And after that, with the irruption of new technologies, new software, use of smarthphones with GPS, satellites and big technological centers owned by companies such as Google (http://www.google.com), new ways for characterizing trips were developed. In this section i will briefly mention the Google Distance Matrix (https://developers.google.com/maps/documentation/distance-matrix/), the pgRouting library (Patrushev 2007) for postGIS and will expand with two R packages, googleway (Cooley 2018) and dodgr (Padgham and Peutschnig 2018). The ODS will provide us the matrix of pairs of zones origin and destinations by mode of transport. Then, we can use any of the mentioned softwares to find the shortest path between each zone. The table 4.1 shows an extraction of the OD matrix for the Metropolitan Area of São Paulo (MASP) in 2007 for motorized individual trips. The fig @ref(fig.zod) shows a map with the location of the zones OD. Table 4.1: Matrix OD for motorized indivitual trips between 06:30 and 08:30 MASP 2007 V101 V102 V103 V104 V105 V106 V107 V108 V109 V110 101 42 0 0 83 0 84 42 0 0 318 102 49 0 10 0 0 20 0 10 0 0 103 0 10 0 19 0 81 17 0 0 54 104 0 35 86 40 0 170 40 35 35 0 105 0 0 0 13 0 0 0 0 0 0 106 94 0 72 87 24 196 15 0 0 27 107 0 0 13 64 13 28 44 0 0 0 108 0 0 0 0 0 0 0 3525 885 0 109 0 0 0 0 0 206 0 3916 975 0 110 954 0 18 954 0 0 0 652 939 2928 Figure 4.2: Zones OD for MASP 2007 Now, as we know the the trips between each pair of OD zones, we can find the routes that connects them. Algorithms are used to find the shortest path. It connects two nodes minimizing the total travel time. There are several algorithms, including Dijkstra (1959). 4.1.3.1 Google Distance Matrix API This service allows to “retrieve duration and distance values based on the recommended route between start and end points.” It returns durations and distance and it is possible to choose modes of transport as well as to choose between current or historical times. The first step is to get a KEY. If you browse https://maps.googleapis.com/maps/api/distancematrix/json?units=imperial&amp;origins=Washington,DC&amp;destinations=New+York+City,NY&amp;key=YOUR_API_KEY and replace YOUR_API_KEY you will see (my brower is in portuguese): { &quot;destination_addresses&quot; : [ &quot;Nova York, NY, EUA&quot; ], &quot;origin_addresses&quot; : [ &quot;Washington, D.C., Distrito de Columbia, EUA&quot; ], &quot;rows&quot; : [ { &quot;elements&quot; : [ { &quot;distance&quot; : { &quot;text&quot; : &quot;225 mi&quot;, &quot;value&quot; : 361972 }, &quot;duration&quot; : { &quot;text&quot; : &quot;3 horas 53 minutos&quot;, &quot;value&quot; : 13964 }, &quot;status&quot; : &quot;OK&quot; } ] } ], &quot;status&quot; : &quot;OK&quot; } The modes of transport covered are driving using the road network, walking via pedestrian paths &amp; sidewalks, bicycling via bicycle paths and transit via public transit routes. For more information read the documentation. 4.1.3.2 pgRouting for postGIS pgRouting (http://pgrouting.org/) is an open source routing library for postGIS. It provides many routing algorithms and it can be run via QGIS (https://www.qgis.org). This library is very extensive. A good resource is the book “pgRouting: A Practical Guide” (http://locatepress.com/pgrouting). 4.1.3.3 The R package googleway googleway (Cooley 2018) R package allows to access Goolge Maps API https://developers.google.com/maps/. The API functions are: Directions - google_directions() Distance Matrix - google_distance() Elevation - google_elevation() Geocoding - google_geocode() Reverse Geocoding - google_reverse_geocode() Places - google_places() Place Details - google_place_details() Time zone - google_timezone() Roads - google_snapToRoads() and google_nearestRoads() This package allows to plot over Google Maps. library(googleway) ## not specifying the api will add the key as your &#39;default&#39; key &lt;- &quot;my_api_key&quot; set_key(key = key) google_keys() ## Google API keys ## - default : my_api_key ## - map : ## - directions : ## - distance : ## - elevation : ## - geocode : ## - places : ## - find_place : ## - place_autocomplete : ## - place_details : ## - reverse_geocode : ## - roads : ## - streetview : ## - timezone : From zone Luz 7, coordinates long -46.63461 and lat -23.53137 to zone 8 Bom Retiro coordinates -46.64482 -23.52204 there are 133 LDV trips between 6:30 and 08:30. We first create the data-frame. This data is based on OD from São Paulo. mydf &lt;- data.frame(region = 1, from_lat = -23.53137, from_long = -46.634613, to_lat = -23.52204, to_long = -46.64482) Then we use the package googleway to create the points between origin and destination and maptools to transform points to lines. library(maptools, quietly = T) library(googleway) foo &lt;- google_directions(origin = unlist(mydf[1, 2:3]), destination = unlist(mydf[1, 4:5]), key = mykey, mode = &quot;driving&quot;, simplify = TRUE) pl &lt;- decode_pl(foo$routes$overview_polyline$points) df &lt;- sf::st_as_sf(pl, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326) streets &lt;- list(x = pl$lon, y = pl$lat) streets &lt;- map2SpatialLines(streets) plot(streets, axes = T, main= &quot;Route of 133 LDV trips&quot;) knitr::include_graphics(path = &quot;figuras/gway.png&quot;) Figure 4.3: Driving route between zones ‘Luz’ and ‘Bom Retiro’ in São Paulo 4.1.3.4 The R package dodgr dpdgr(Padgham and Peutschnig 2018) is a new R package with great capbilities. It calculates the distance on dual-weight graphs using priority-queue shortest paths. In order to calculate the traffic flows it is necessary to have the matrix OD for the desired mode of transport and the coorodinates of centroids of the OD zones. The function dodgr_streetnet uses the osmdata r package to download street network data from Open Street Map (contributors 2017) for the points of the centroids of zones OD. Depending on the spatial extent of the data, the resulting data can be large. The function weight_streetnet weight the lines from OSM road network according to a specific profile of traffic: “psv” for Public Service Vehicle. “bicycle”, nd others. The weights are profile values for the OSM type of roads based on this webpage: https://www.routino.org/xml/routino-profiles.xml. The function dodgr_vertices extract the vertices pf thegraph including the coordinates. Finally, the function dodgr_flowmap reads the graph and plots the flows. Below is an example for São Paulo using the data of ODS (Metro 2017). Figure 4.4: Daily trips of Light Duty Vehicles in São Paulo 4.1.4 Top-down approach VEIN was designed with traffic flow at street leve on mind, however, it is possible that user might want or need to use a top-down approach. Here are some possible causes: Bottom-up approach can demand more computatonal resources for a country or a continent. Another possibility is that the emissions inventory is going to be used solely for air quality modelling purposes, where the proportion of grid spacing and street is such that spatial detail would be lose, for instance with resolution of 10 km. Also, it is possible that there is no way of obtaining traffic information at street level. Limited resources, time, funding, human resources, etc. Lastly, due to simplism. It is also possible that the objective simply is to estimate an emissions inventory using a top-down approach. Under these circumstances a top-down approach would be better suited for some users. As VEIN is a toolkit for estimating emissions, it is reasonable to use all VEIN resources with a top-down approach. In this case, the user must follow some considerations: Use inventory functions in the same way as shown on section 3. Create a network, but instead of using a road network with spatial lines, use spatial polygons. The Spatial polygon might represent some area where the amount of vehicles is known. The age functions shown in following sections, show that it is possible to apply age distributions to each street, in this case, to each area. The Fig. 4.5 shows the emissions of PM for each state Brazil and prepared for a congress using VEIN as a top-down tool (Sergio Ibarra-Espinosa, Freitas, et al. 2018). Figure 4.5: Emissions of PM due trafifc, 2017 4.2 Main functions The Fig.(3.1) shows a complete diagram with the steps for elaborating an emissions inventory. Also, the function inventory shown on sub-section (3.1) shows the functions to structure an inventory. This and the following subsection of application shows respective the part of the diagram Fig.(4.6) and how to run VEIN as well as storing the results in the directories shown in Fig. (3). The first element that the user must have is the traffic at street level. This is shown as a green circle with the word ‘traffic’ on Fig. (4.6). The user must use any age function which produces objects of class Vehicles. The function netspeed produces an object of class Speed. This objects are required by the emis function. Figure 4.6: Structuring an emissions inventories with VEIN 4.2.1 Expanding traffic data with the function temp_fact Traffic data must be temporally extrapolated because it is usually available only for the morning rush hour. Traffic data can be estimated from short period traffic count datasets, then expanded to represent longer timespan, such as Annual Average Daily Traffic (AADT; (Wang and Kockelman 2009, lam2000estimation)). The next step is to extrapolate the vehicular flow at street link \\(i\\), vehicle type \\(j\\), and age of use \\(k\\), to obtain the vehicular flow for hour of the week \\(l\\) (\\(F_{i,j,k,l}\\); see equation (4.2). \\[\\begin{equation} F_{i,j,k,l} = F^*_{i,j,k} \\cdot TF_{j,l} \\tag{4.2} \\end{equation}\\] where \\(TF_{j,l}\\) are the temporal factors varying according to each hour of \\(l\\) and type of vehicle \\(j\\). For instance, \\(TF\\) is defined as a matrix with 24 lines and numbers of columns to each day considered, from Monday to Sunday. In order to expand traffic to other hours, \\(TF\\) matrices must be normalized to the hour that represents the traffic data. It means that \\(TF\\) values at morning peak hour must be 1 and the respective proportion must be assigned to the other hours. For example, \\(TF\\) values can be obtained from automatic traffic count stations. The function temp_fact return \\(F_{i,j,k,l}\\) as an object with class Vehicles. The arguments are: q is a data-frame of traffic flow to each hour (veh/h) at each street. pro s a matrix or data-frame to extrapolate . 4.2.2 Calculating speed at other hours with the function netspeed The average speed of traffic flow is very important and it must be determined for each link and hour. Once the vehicular flow is identified for each hour, the average speed is then identified for each hour. This was accomplished by employing curves from the Bureau of Public Roads (BPR; (Bureau of Public Roads 1964)), as shown in Eq. (4.3). The process involves calculating speed by dividing the length of road by the time. The time is calculated using the total traffic expanded to each street link \\(i\\) and hour \\(l\\). \\[\\begin{equation} T_{i,l} = To_i \\cdot \\left(1 +\\alpha \\cdot \\left(\\dfrac{Q_{i,l}}{C_i}\\right)^\\beta \\right) \\tag{4.3} \\end{equation}\\] The function netspeed do this calculations. The arguments of this function are: args(netspeed) ## function (q = 1, ps, ffs, cap, lkm, alpha = 0.15, beta = 4, net, ## scheme = FALSE, distance = &quot;km&quot;, time = &quot;h&quot;, isList) ## NULL netspeed allows basically creates two types of speeds data-frames which depends on the availability of data by the user. If the user has q, ps, ffs and cap the user can use the argument scheme = FALSE, or when the user only has ps and ffs the user can use the argument scheme = TRUE. q is a data-frame of traffic flow to each hour (veh/h) at each street. psis the Peak speed (km/h) at each street. ffs Free flow speed (km/h) at each street. cap Capacity of link (veh/h) at each street. lkm Distance of link (km) of each street. alpha Parameter of Bureau of Public Roads (1964) curves. beta Parameter of Bureau of Public Roads (1964) curves. scheme Logical to create a Speed data-frame with 24 hours and a default profile. It needs ffs and ps at each street: Table 4.2: speeds for scheme = T Period Speed 00:00-06:00 ffs (Free flow speed) 06:00-07:00 average between ffs and ps 07:00-10:00 ps (Peakspeed) 10:00-17:00 average between ffs and ps 17:00-20:00 ps (Peak speed) 20:00-22:00 average between ffs and ps 22:00-00:00 ffs (Free flow speed) 4.2.3 Distribution of vehicles by age of use with the functions age_ldv, age_hdv and age_moto These functions reads traffic data at each street and return an object of class Vehicles, which is a data-frame with the number of vehicles at each street and the number of columns represent the amount of vehicles at each age. The functions age_moto and age_hdv are identical. These functions apply survival equations into the fleet from Ministerio do Meio Ambiente (2011). The arguments are: xnumerical vector of vehicles at each street. name word of vehicle assigned to columns of dataframe. a parameter of survival equation. The default value for age_ldv is 1.698 and for age_hdv and age_moto is 0.2. b parameter of survival equation. The default value for age_ldv is -0.2 and for age_hdv and age_moto is 17. agemin age of newest vehicles for that category. The default value is 1, however it can be bigger than one when it is a vehicle that is not circulating more then a year ago. agemax age of oldest vehicles for that category. The default value is 50 assuming that the oldest vehicle in circulation has 50 years of use. However, new type of vehicles will be newer. k multiplication factor. This factor helps to split the traffic x in the vehicular composition. bystreet when TRUE it is expecting that a and b are numeric vectors with length equal to x. In other words, the values of a and b varies in each street. message message with average age and total number of vehicles. 4.2.4 The function my_age These functions also reads traffic data at each street and returns an object of class Vehicles, which is a data-frame with the number of vehicles at each street and the columns represent the amount of vehicles at each age. However, it is based on data the user has and not by parameters. Therefore, using this function with own data should produce more representative results. The arguments are: args(my_age) ## function (x, y, name = &quot;age&quot;, k = 1, pro_street, net, message = TRUE) ## NULL x numerical vector of vehicles at each street. y Age distribution of vehicles. This parameter can be annual sales or annual registry for the category of vehicle. name of vehicle assigned to columns of dataframe. k multiplication factor. This factor helps to split the traffic x in the vehicular composition. message message with average age and total number of vehicles. 4.2.5 The class Vehicles Vehicles is a class in VEIN, shown in on Fig. (4.6). This class includes the methods print, plot and summary. This means that, Vehicles objects presents customized versions of print, plot and summary in order to make easier to the user to use VEIN. The figure @ref(fig.plotpc) shows a simple plot of a Vehicles object, followed by the head of this object. The plot shows the sum of each type of vehicle by age of use, with a vertical red line indicating the average age, 11.17 years of use. library(vein) data(net) PC_E25 &lt;- age_ldv(x = net$ldv,name = &quot;PC_E25&quot;, k = 75/100*37.25, message = F) plot(PC_E25) ## ## Average = 11.17 head(PC_E25[, 1:4]) # The first 4 columns ## Result for Vehicles ## V1 V2 V3 V4 ## 1 1761.92888 [1/h] 2968.78285 [1/h] 4404.60761 [1/h] 5877.97812 [1/h] ## 2 591.76508 [1/h] 997.10155 [1/h] 1479.34063 [1/h] 1974.18989 [1/h] ## 3 240.18939 [1/h] 404.70994 [1/h] 600.44421 [1/h] 801.29679 [1/h] ## 4 341.44967 [1/h] 575.32964 [1/h] 853.58258 [1/h] 1139.11162 [1/h] ## 5 22.27726 [1/h] 37.53633 [1/h] 55.69044 [1/h] 74.31926 [1/h] ## 6 1163.27810 [1/h] 1960.07916 [1/h] 2908.05358 [1/h] 3880.81682 [1/h] 4.2.6 Other traffic functions Another function is adt which calculates average daily traffic (ADT) from hourly traffic data. This function reads numeric vectors with the amount of vehicles at each street and expands the traffic with temporal factors for each type of vehicle. The arguments are: args(adt) ## function (pc, lcv, hgv, bus, mc, p_pc, p_lcv, p_hgv, p_bus, p_mc, ## expanded = FALSE) ## NULL pc numeric vector for passenger cars lcv numeric vector for light commercial vehicles hgv numeric vector for heavy good vehicles or trucks bus numeric vector for bus mc numeric vector for motorcycles p_pc data-frame profile for passenger cars p_lcv data-frame profile for light commercial vehicles p_hgv data-frame profile for heavy good vehicles or trucks p_bus data-frame profile for bus p_mc data-frame profile for motorcycles 4.3 Vehicular composition 4.4 Application As mentioned above, the application consists in using the travel demand model for west part of São Paulo city, present in VEIN. This script reads traffic data and expands it applying an age function. It uses the inventory function with the default vehicular composition, shown on section (@red(st)). Please, use the scripts in the extra material of this book. The base year is 2015 and the extended example is available in appendix 1. library(vein) inventory(file.path(tempdir(), &quot;YourCity&quot;)) setwd(&quot;YourCity&quot;) data(net) # Loads the traffic demand simulation for west São Paulo data(net) data(pc_profile) pc_week &lt;- temp_fact(net$ldv+net$hdv, pc_profile) speed &lt;- netspeed(pc_week, net$ps, net$ffs, net$capacity, net$lkm) saveRDS(net, file = &quot;network/net.rds&quot;) saveRDS(speed, file = &quot;network/speed.rds&quot;) Appendix B "],
["ef.html", "Chapter 5 Emission Factors 5.1 Speed functions ef_ldv_speed and ef_hdv_speed 5.2 Local emission factors by age of use. The functions EmissionFactors and EmissionFactorsList 5.3 Incorporating speed variation with the functions ef_ldv_scaled and ef_hdv_scaled 5.4 Cold Starts 5.5 Deterioration 5.6 Evaporative emissions ef_evap 5.7 Emission factors of wear ef_wear 5.8 Emission factors from tunnel studies 5.9 Emission factors from International Vehicle Emissions (IVE) 5.10 Emission factors from the Environmental Agency of São Paulo", " Chapter 5 Emission Factors An emission factor is the amount of mass of pollutant generated by activities (Pulles and Heslinga 2010). In the case of vehicles, the emission factors are generally known as the mass of pollutant per traveled distance \\(g \\cdot km^{-1}\\) in metric units. The distance unit could be different, like miles for instance. The type of units depends on measurement used when developing the emission factors. There are hot and cold exhaust emisions. Hot exhaust emissions are produced by a vehicle when its engine and exhaust after-treatment system are at their normal operational temperatures and Cold during the vehicle warm-up phase (P et al. 2009). The emission factors come from measurements of pollutants emitted by the sources. In the case of vehicles, the dynanometer measurements of the emission factors are the mass of pollutant collected during the distance traveled by a vehicle following a specific driving cycle. The Federal Test Procedure (FTP) is a test to certify the vehicle emissions under the driving cycles such as FTP-75. This driving cycle has a duration of 1874 \\(s\\) for a distance of 17783 \\(m\\) and an average speed of 34.12 \\(km \\cdot h^{-1}\\) (Barlow 2009). In the literature it is possible to find different type of emission factors. For instance, in Europe, during the development of the project Assesment of Reliability of Transport Emission Models and Inventory Systems (ARTEMIS), the traffic situation model was developed. The model concept consists in the combination of parameters that affects vehicle kinematics and engine operation: type of road, sinuosity and gradient, trafffic conditions or level of service (free-flow, heavy, saturated and stop and go) and average speed by speed limit of the road (Boulter and Barlow 2009). Measurements of vehicular emissions under each traffic situation lead to emission factors by traffic situation, used in the Handbook of Emission Factors (HBEFA, www.hbefa.net). There is another approach based on 1 Hz measurement of emissions. Here, the pollutants are measured on real live traffic driving. Emission factors can be derived here using mainly two approaches. One approach is applying the Vehicular Specific Power (VSP) (Jimenez et al. 1999). This method is used in the Motor Vehicle Emission Simulator (MOVES) (Koupal et al. 2003) and the International Vehicle Emissions model (IVE) (Davis et al. 2005). Another approach is to apply the Passenger car and Heavy-duty Emission Model (PHEM), which is based on instantaneous engine power demand and engine speed developed during the ARTEMIS project (Barlow 2009, Boulter and Barlow (2009)). Perhaps the most used approach to obtain emission factors are speed functions. As emissions tests on driving cycles are valid for only one average speed, measuring emissions of different driving cycles at different average speeds, allows to obtain point clouds where a regression is applied, obtaining an emission factor as a speed function. The literature shows experiments in diffferent parts of the world, such as in Chile (Corvalán, Osses, and Urrutia 2002) and Europe (Ntziachristos and Samaras 2000). However, probably the most used source of emission factors as speed functions are the European emission guidelines developed by the European Monitoring and Evaluation Programme (EMEP, http://www.emep.int/) and published by the European Environment Agency (EEA, https://www.eea.europa.eu/themes/air/emep-eea-air-pollutant-emission-inventory-guidebook/emep) (Ntziachristos and Samaras 2016). These emission factors are included in the VEIN model. Another aspect important in vehicular emissions is the degradation of the emissions of aged vehicles. Over the time, different part of the vehicles suffer deterioration, increasing the emissions. Therefore, approaches have been developed to account for this effect in inventories. One approach consists in determining functions that increment the emissions by accumulated mileage, such as studies of Corvalán and Vargas (2003). In Brazil, the emission factors are reported by the Environmental Protection Agency of São Paulo CETESB (2015), in their vehicular emissions inventory report. Light vehicles emission factors come from average measurements of the FTP75 driving cycle, motorcycle emission factors come from average measurements of World Motorcycle Test Cycle (WMTC) and HDV from the European Stationary Cycle (ETC). As the VEIN model was developed in Brazil, but users of other parts of the world may be intereted in using the model, the approach in VEIN has to allow flexibility to the user. Therefore, the emission factors approach in VEIN consists in three options, as shown on Fig. (5.1). The first approach consists in local emissions factors by age of use, such as the one from CETESB (2015), denoted as local_ef in the green circle. The second approach consists in selecting speed functions from Ntziachristos and Samaras (2016), availabe in VEIN and denoted as the grey box as speed_ef. The third approach conists in incorporating speed variation from the speed function into the local emission factors by age of use. In any case, VEIN uses a function to account for the degradation of emissions due to accumulated mileage (denoted in grey box as emis_det). These emissions are entered into the emission estimation function. The following sections show how to do these calculation in VEIN, step by step. Figure 5.1: Structuring an emissions inventories with VEIN 5.1 Speed functions ef_ldv_speed and ef_hdv_speed The estimation of emissions in VEIn is shown the equation (5.1): \\[\\begin{equation} EH_{i,j,k,l,m} =F_{i,j,k,l} \\cdot L_i \\cdot EF(V_{i,l})_{j,k,m} \\cdot DF_{j,k} \\tag{5.1} \\end{equation}\\] where \\(EH_{i,j,k,l,m}\\) is the emission for each street link \\(i\\), vehicle category from composition \\(k\\), hour \\(l\\) and pollutant \\(m\\), \\(F_{i,j,k,l}\\) is the vehicular flow calculated in Eq. 1. \\(L_i\\) is the length of the street link \\(i\\). \\(EF(V_{i,l})_{j,k,m}\\) is the emission factor of each pollutant \\(m\\). \\(DF_{j,k}\\) is the deterioration factor for vehicle of type \\(j\\) and age of use \\(k\\), explained in detail in section 5.5. These functions return speed functions as \\(f(V)\\). The functions come from the EMEP/EEA emissions guidelines (Ntziachristos and Samaras 2016) and are available in PDF reports. The equations and their parameters were translated to spreedsheets and loaded internally in VEIN. Therefore, the user only must enter the required parameters obtaining the desired function. The functions respect the assumptions and speed limits. 5.1.1 Emission factors of LDV depending on speed with the function ef_ldv_speed The arguments for ef_ldv_speed are: v: Category of vehicle: “PC”, “LCV”, “Motorcycle” or “Moped”. t: Sub-category of vehicle: PC: “ECE_1501”, “ECE_1502”, “ECE_1503”, “ECE_1504” , “IMPROVED_CONVENTIONAL”, “OPEN_LOOP”, “ALL”, “2S” or “4S”. LCV: “4S”, Motorcycle: “2S” or “4S”. Moped: “2S” or “4S”. cc: Size of engine in cc: PC: “&lt;=1400”, “&gt;1400”, “1400_2000”, “&gt;2000”, “&lt;=800”, “&lt;=2000”. Motorcycle: “&gt;=50” (for “2S”), “&lt;=250”, “250_750”, “&gt;=750”. Moped: “&lt;=50”. LCV : “&lt;3.5” for gross weight. f: Type of fuel: “G”, “D”, “LPG” or “FH” (Full Hybrid: starts by electric motor). eu: Euro standard: “PRE”, “I”, “II”, “III”, “III+DPF”, “IV”, “V”, “VI” or “VIc”. p: Pollutants: Criteria: “CO”, “NOx”, “HC”, “PM”, “CH4”, “NMHC”, “CO2”, “SO2”, “Pb”, “FC” (Fuel Consumption).- PAH and POP: “indeno(1,2,3-cd)pyrene”, “benzo(k)fluoranthene”, “benzo(b)fluoranthene”, “benzo(ghi)perylene”, “fluoranthene”, “benzo(a)pyrene”, “pyrene”, “perylene”, “anthanthrene”, “benzo(b)fluorene”, “benzo(e)pyrene”, “triphenylene”, “benzo(j)fluoranthene”, “dibenzo(a,j)anthacene”, “dibenzo(a,l)pyrene”, “3,6-dimethyl-phenanthrene”, “benzo(a)anthracene”, “acenaphthylene”, “acenapthene”, “fluorene”, “chrysene”, “phenanthrene”, “napthalene”, “anthracene”, “coronene”, “dibenzo(ah)anthracene” Dioxins and Furans: “PCDD”, “PCDF”, “PCB”. Metals: “As”, “Cd”, “Cr”, “Cu”, “Hg”, “Ni”, “Pb”, “Se”, “Zn”. NMHC: - ALKANES: “ethane”, “propane”, “butane”, “isobutane”, “pentane”, “isopentane”, “hexane”, “heptane”, “octane”, “TWO_methylhexane”, “nonane”, “TWO_methylheptane”, “THREE_methylhexane”, “decane”, “THREE_methylheptane”, “alcanes_C10_C12”, “alkanes_C13”. CYCLOALKANES: “cycloalcanes”. ALKENES: “ethylene”, “propylene”, “propadiene”, “ONE_butene”, “isobutene”, “TWO_butene”, “ONE_3_butadiene”, “ONE_pentene”, “TWO_pentene”, “ONE_hexene”, “dimethylhexene”. ALKYNES:“ONE_butine”, “propine”, “acetylene”. ALDEHYDES: “formaldehyde”, “acetaldehyde”, “acrolein”, “benzaldehyde”, “crotonaldehyde”, “methacrolein”, “butyraldehyde”, “isobutanaldehyde”, “propionaldehyde”, “hexanal”, “i_valeraldehyde”, “valeraldehyde”, “o_tolualdehyde”, “m_tolualdehyde”, “p_tolualdehyde”. KETONES: “acetone”, “methylethlketone”. AROMATICS: “toluene”, “ethylbenzene”, “m_p_xylene”, “o_xylene”, “ONE_2_3_trimethylbenzene”, “ONE_2_4_trimethylbenzene”, “ONE_3_5_trimethylbenzene”, “styrene”, “benzene”, “C9”, “C10”, “C13”. k: Multiplication factor. show.equation: Option to see (or not) the equation parameters. It is very important that the user enters the right values into the arguments because the final category must match. If the user enters values that do not match, the resulting speed function will be wrong. There are 146 matchs. The probably most used combinations are: Table 5.1: Most used combinations for emission factors for LDV Argument Value v PC LCV Motorcycles t 4S cc &lt;=1400 1400_2000 &gt;2000 f G D eu PRE I II III IV V VI p CO NOx HC FC PM The returning speed function represents how a type of vehicle emits pollutants on average. Fig. (5.2) shows the emissions of CO by Passenger Cars with with technologies Pre Euro and Euro I from Ntziachristos and Samaras (2016). Higher emissions occure at low average speeds and older vehicles with technologies pre Euro emit more than vehicles with Euro I. Even more, the average emissions of Pre Euro are 29.31 \\(g \\cdot km^{-1}\\) and Euro I 2.61 \\(g \\cdot km^{-1}\\), meaning that, on average, a vehicle Pre euro is 14 times higher than a vehicle with euro I. The Fig. (5.2) shows the plot using the package ggplot2 (Wickham 2009). This package requires that the data must be in long format. library(vein) library(ggplot2) ef1 &lt;- ef_ldv_speed(v = &quot;PC&quot;, cc = &quot;&lt;=1400&quot;, f = &quot;G&quot;, eu = &quot;PRE&quot;, p = &quot;CO&quot;, show.equation = F) ef2 &lt;- ef_ldv_speed(v = &quot;PC&quot;, cc = &quot;&lt;=1400&quot;, f = &quot;G&quot;, eu = &quot;I&quot;, p = &quot;CO&quot;, show.equation = F) V &lt;- 0:110 df &lt;- data.frame(EF = c(ef1(V), ef2(V))) df$V = V df$Euro &lt;- factor(c(rep(&quot;PRE&quot;, 111), rep(&quot;I&quot;, 111)), levels = c(&quot;PRE&quot;, &quot;I&quot;)) ggplot(df, aes(V, EF, colour = Euro)) + geom_point(size = 3) + geom_line() + theme_bw()+ labs(y = &quot;CO[g/km]&quot;, x = &quot;[km/h]&quot;) Figure 5.2: Emission factor as a speed function 5.1.2 Emission factors of HDV depending on speed with the function ef_hdv_speed The arguments for ef_hdv_speed are: args(ef_hdv_speed) ## function (v, t, g, eu, x, gr = 0, l = 0.5, p, k = 1, show.equation = FALSE) ## NULL v Category of vehicle: “Coach”, “Trucks” or “Ubus” t Sub-category of vehicle: “3Axes”, “Artic”, “Midi”, “RT,”Std&quot; and “TT” g Gross weight of each category: “&lt;=18”, “&gt;18”, “&lt;=15”, “&gt;15 &amp; &lt;=18”, “&lt;=7.5”, - “&gt;7.5 &amp; &lt;=12”, “&gt;12 &amp; &lt;=14”, “&gt;14 &amp; &lt;=20”, “&gt;20 &amp; &lt;=26”, “&gt;26 &amp; &lt;=28”, “&gt;28 &amp; &lt;=32”, “&gt;32”, “&gt;20 &amp; &lt;=28”, “&gt;28 &amp; &lt;=34”, “&gt;34 &amp; &lt;=40”, “&gt;40 &amp; &lt;=50” or “&gt;50 &amp; &lt;=60” `eu Euro emission standard: “PRE”, “I”, “II”, “III”, “IV” and “V” `gr Gradient or slope of road: -0.06, -0.04, -0.02, 0.00, 0.02. 0.04 or 0.06 l Load of the vehicle: 0.0, 0.5 or 1.0 p Pollutant: Criteria: “CO”, “NOx”, “HC”, “PM”, “CH4”, “NMHC”, “CO2”, “SO2”, “Pb”, “FC” (Fuel Consumption).- PAH and POP: “indeno(1,2,3-cd)pyrene”, “benzo(k)fluoranthene”, “benzo(b)fluoranthene”, “benzo(ghi)perylene”, “fluoranthene”, “benzo(a)pyrene”, “pyrene”, “perylene”, “anthanthrene”, “benzo(b)fluorene”, “benzo(e)pyrene”, “triphenylene”, “benzo(j)fluoranthene”, “dibenzo(a,j)anthacene”, “dibenzo(a,l)pyrene”, “3,6-dimethyl-phenanthrene”, “benzo(a)anthracene”, “acenaphthylene”, “acenapthene”, “fluorene”, “chrysene”, “phenanthrene”, “napthalene”, “anthracene”, “coronene”, “dibenzo(ah)anthracene” Dioxins and Furans: “PCDD”, “PCDF”, “PCB”. Metals: “As”, “Cd”, “Cr”, “Cu”, “Hg”, “Ni”, “Pb”, “Se”, “Zn”. NMHC: - ALKANES: “ethane”, “propane”, “butane”, “isobutane”, “pentane”, “isopentane”, “hexane”, “heptane”, “octane”, “TWO_methylhexane”, “nonane”, “TWO_methylheptane”, “THREE_methylhexane”, “decane”, “THREE_methylheptane”, “alcanes_C10_C12”, “alkanes_C13”. CYCLOALKANES: “cycloalcanes”. ALKENES: “ethylene”, “propylene”, “propadiene”, “ONE_butene”, “isobutene”, “TWO_butene”, “ONE_3_butadiene”, “ONE_pentene”, “TWO_pentene”, “ONE_hexene”, “dimethylhexene”. ALKYNES:“ONE_butine”, “propine”, “acetylene”. ALDEHYDES: “formaldehyde”, “acetaldehyde”, “acrolein”, “benzaldehyde”, “crotonaldehyde”, “methacrolein”, “butyraldehyde”, “isobutanaldehyde”, “propionaldehyde”, “hexanal”, “i_valeraldehyde”, “valeraldehyde”, “o_tolualdehyde”, “m_tolualdehyde”, “p_tolualdehyde”. KETONES: “acetone”, “methylethlketone”. AROMATICS: “toluene”, “ethylbenzene”, “m_p_xylene”, “o_xylene”, “ONE_2_3_trimethylbenzene”, “ONE_2_4_trimethylbenzene”, “ONE_3_5_trimethylbenzene”, “styrene”, “benzene”, “C9”, “C10”, “C13”. k: Multiplication factor. k Multiplication factor show.equation Option to see or not the equation parameters V &lt;- 0:130 ef1 &lt;- ef_hdv_speed(v = &quot;Trucks&quot;,t = &quot;RT&quot;, g = &quot;&lt;=7.5&quot;, e = &quot;II&quot;, gr = 0, l = 0.5, p = &quot;HC&quot;, show.equation = FALSE) ef2 &lt;- ef_hdv_speed(v = &quot;Trucks&quot;,t = &quot;RT&quot;, g = &quot;&lt;=7.5&quot;, e = &quot;II&quot;, gr = 0.06, l = 0.5, p = &quot;HC&quot;, show.equation = FALSE) plot(1:130, ef1(1:130), pch = 16, type = &quot;b&quot;, ylab = &quot;HC [g/km]&quot;, xlab = &quot;Speed [km/h]&quot;) lines(1:130, ef2(1:130), pch = 16, type = &quot;b&quot;, col = &quot;blue&quot;) 5.2 Local emission factors by age of use. The functions EmissionFactors and EmissionFactorsList The functions EmissionFactors and EmissionFactorsList create the classes with same names. The class EmissionFactors is also a data-frame with numeric columns with units of \\(g \\cdot km^{-1}\\). This class is not used in critical steps of VEIN, and it has a purpose of creating a data-frame with numeric columns and units. The function is applied to a numeric vector and it just converts it to units adding units to it. In the case of EmissionFactorsList, this class is a list of functions \\(f(V)\\). This is usefull because the emis function, seen in detail on chapter 6, requires that the emission factors are functions of velocity \\(f(V)\\), regardless \\(f(V)\\) if it is constant or not. When this function is applied to a data-frame or to a matrix, it returns a list and each column of the data-frame or matrix is another list. Also, each row of the original data-frame is converted to a \\(f(V)\\). The arguments or EmissionFactorsList and EmissionFactors are: -x: Object with class “data.frame”, “matrix” or “numeric” The following lines of code show examples using EmissionFactors. Firstly, it is loaded the dataset of emission factors fe2015 for CO and the vehicles PC using gasoline PC_G and Light Trucks LT. The class of fe2015 is data-frame. The subset of the data is named DF_CO. The first 6 elemens of the data-frame are numbers without units. library(vein) data(fe2015) #CETESB Emission factors DF_CO &lt;- fe2015[fe2015$Pollutant==&quot;CO&quot;, c(&quot;PC_G&quot;, &quot;LT&quot;)] head(DF_CO) ## PC_G LT ## 1 0.171 0.027 ## 2 0.216 0.012 ## 3 0.237 0.012 ## 4 0.273 0.005 ## 5 0.275 0.379 ## 6 0.204 0.416 The object EF_CO is of class EmissionFactors and “data-frame” and each observation has the units \\(g \\cdot km^{-1}\\). EF_CO &lt;- EmissionFactors(DF_CO) head(EF_CO) ## EmissionFactors: ## PC_G LT ## 1 0.171 [g/km] 0.027 [g/km] ## 2 0.216 [g/km] 0.012 [g/km] ## 3 0.237 [g/km] 0.012 [g/km] ## 4 0.273 [g/km] 0.005 [g/km] ## 5 0.275 [g/km] 0.379 [g/km] ## 6 0.204 [g/km] 0.416 [g/km] class(EF_CO) ## [1] &quot;EmissionFactors&quot; &quot;data.frame&quot; The plot of an object of class EmissionFactors shows maximum 9 emission factors. Fig. (5.3) shows the emission factors of both categories, where newer vehicles emit less and older vehicles emit more. plot(EF_CO, xlab = &quot;Age of use&quot;) Figure 5.3: Emission factor of PC and LT by age of use Regarding the class EmissionFactorsList, the print and summary methods are very simple, only showing a description of the object. The example of the following lines of code also uses the same set of Emission Factors from CETESB (2015). The resulting object, EF_COL, is of class EmissionFactorsList and list. The print of the object shows only a description of the first and last member of the list object. EFL_CO &lt;- EmissionFactorsList(DF_CO) class(EFL_CO) ## [1] &quot;EmissionFactorsList&quot; &quot;data.frame&quot; EFL_CO ## This EmissionFactorsList has 2 lists ## First has 36 functions ## Last has 36 functions Indeed, if we want to see the content of the EmissionFactorsList we have to extract the elements of the list. EFL_CO has two lists; one for PC and one for LT. Then, each list has 36 functions, the command class(EFL_CO[[1]][[1]]) shows the object is a function \\(f(V)\\). EFL_CO[[1]][[1]] ## function(V) x[j,i] ## &lt;bytecode: 0x55712886ea90&gt; ## &lt;environment: 0x557128838120&gt; Also, as the speed functions are constant, there is no need to add values of V. EFL_CO[[1]][[1]](100) # constant speed function ## [1] 0.171 EFL_CO[[1]][[1]](0) # constant speed function ## [1] 0.171 Finally, after extracting the value, Fig. (5.4) shows the same figure as Fig. (5.3) efco1 &lt;- sapply(1:36, function(i) EFL_CO[[1]][[i]]()) efco2 &lt;- sapply(1:36, function(i) EFL_CO[[2]][[i]]()) df &lt;- EmissionFactors(cbind(efco1, efco2)) plot(df, xlab = &quot;Age of use&quot;) Figure 5.4: Emission factor of PC and LT 5.3 Incorporating speed variation with the functions ef_ldv_scaled and ef_hdv_scaled The functions in section 5.1 and 5.2 showed the speed and local emission factors respectively. However, the user might have local and constant emission factors depending only on the age of use, but also, outputs from a traffic demand model which includes speed. Under those circumstances, it would be interesting to investigate the effects of the average speed of traffic flow. VEIN includes functions to transform a constant emission factor by age of use into a speed dependent function. These functions are called ef_ldv_scaled and ef_hdv_scaled. The concept is explained in detail in my Ph.D thesis (Ibarra-Espinosa 2017). The idea comes from revisiting the nature of the local emission factors. The Brazilian emission factors consist of average measurements for emissions certification tests which use the driving cycles Federal Test Procedure FTP-75 for LDV, World Motorcycle Test Cycle (WMTC) for motorcycles, and also the European Stationary Cycle (ESC) for HDV (CETESB 2015). The average speed of FTP-75 and WMTC are known, being 34.2 \\(km \\cdot h^{-1}\\) and 54.7 \\(km \\cdot h^{-1}\\) based on the reference report on driving cycles from the Transport and Research Laboratory (TRL) (Barlow 2009). In the case of ESC, the user might search on literature a way to relate this cycle with an average speed. Coming back to the CETESB (2015) emission factors, these are annual average values of emissions for the different technologies to accomplish Brazilian emission standards, which are valid only for a specific average speed.If two vehicles have similar technology but different emission factors, one constant and other speed function, it would be possble to relate them. These functions use the speed to relate both emission factors. The condition to transform a contant emission factor into a speed dependent function is that, the new speed dependent function must be of the same value at the speed which is representative for the local factor, and the values at other speeds are the incorporation of the speed variation. The equation (5.2) shows the procedure: \\[\\begin{equation} EF_{scaled}(V_{i,l})_{j,k,m}=EF(V_{i,l})_{j,k,m} \\cdot \\frac{EFlocal_{j,k,m}}{{EF(Vdc_{i,l})_{j,k,m}}} \\tag{5.2} \\end{equation}\\] Where \\(EF_{scaled}(V_{i,l})_{j,k,m}\\) is the scaled emission factor and \\(EF(V_{i,l})_{j,k,m}\\) is the Copert emission factor for each street link \\(i\\), vehicle from composition \\(k\\), hour \\(l\\) and pollutant \\(m\\). \\(EFlocal_{j,k,m}\\) represents the constant emission factor (not as speed functions). \\(EF(Vdc_{i,l})_{j,k,m}\\) are Copert emission factors with average speed value of the respective driving cycle for the vehicular category \\(j\\). The functions ef_ldv_scaled and ef_hdv_scaled return scaled emissions factors automatically. The arguments are: df: Data-frame with emission factors (Deprecated in 0.3.10). dfcol: Numeric vector with the emission factors constant by age of use. These emission factors are the target to incorporate speed variation. SDC: A number with the speed of the driving cycle of the emission factors from the argument dfcol. The resulting speed functions will return the same values of dfcol at the speed SDC. The default is 34.12 “km/h”. v. Category of vehicle: “PC”, “LCV”, “Motorcycle” or “Moped”. t. Character; sub-category of vehicle: PC: “ECE_1501”, “ECE_1502”, “ECE_1503”, “ECE_1504” , “IMPROVED_CONVENTIONAL”, “OPEN_LOOP”, “ALL”, “2S” or “4S”. LCV: “4S”, Motorcycle: “2S” or “4S”. Moped: “2S” or “4S”. The default is 4S. cc. Character; size of engine in cc: PC: “&lt;=1400”, “&gt;1400”, “1400_2000”, “&gt;2000”, “&lt;=800”, “&lt;=2000”. Motorcycle: “&gt;=50” (for “2S”), “&lt;=250”, “250_750”, “&gt;=750”. Moped: “&lt;=50”. LCV : “&lt;3.5” for gross weight. f: Character; type of fuel: “G”, “D”, “LPG” or “FH” (Full Hybrid: starts by electric motor). eu: Character; euro standard: “PRE”, “I”, “II”, “III”, “III+DPF”, “IV”, “V”, “VI” or “VIc”. p: Character; pollutant: “CO”, “FC”, “NOx”, “HC” or “PM”. And the argument of ef_hdv_scaled are: !! something is missing here!! 5.4 Cold Starts Cold start emissions are produced during engine startup, when the engine and/or catalytic converter system has not reached its normal operational temperature. Sev- eral studies have shown the significant impact for these types of emissions (Chen et al. 2011, Weilenmann, Favez, and Alvarez (2009)). Under this condition emissions will be higher, and if the atmospheric temperature decreases, cold start emissions will increase regardless of whether the catalyst has reached its optimum temperature for functioning (Boulter and Barlow 2009). VEIN also considers cold start emissions using the approach outlined in Copert (Ntziachristos and Samaras 2016), as shown in equation (5.3). \\[\\begin{equation} EC_{i,j,k,l,m} =\\beta_{j} \\cdot F_{i,j,k,l} \\cdot L_i \\cdot EF(V_{i,l})_{j,k,m} \\cdot DF_{j.k} \\cdot \\left(EF_{\\mbox{cold}}(ta_n,V_{i,l})_{j,k,m}-1\\right) \\tag{5.3} \\end{equation}\\] This approach adds two terms to Eq. . The first term \\(EF_{cold}(ta_n,V_{i,l})_{j,k,m}-1\\) is the emission factors for cold start conditions at each street link \\(i\\), vehicle category from composition \\(k\\), hour \\(l\\) and pollutant \\(m\\) and monthly average temperature \\(n\\). (Ntziachristos and Samaras 2016) suggest using monthly average temperature. This is an important aspect that will be reviewed in future versions of VEIN. The second term \\(\\beta_j\\) is defined as the fraction of mileage driven with a cold engine/catalyst (Ntziachristos and Samaras 2016). The VEIN model incorporates a dataset of cold starts recorded during the implementation of the International Vehicle Emissions (IVE) model (Davis et al. 2005) in São Paulo (Lents et al. 2004), which provides the hourly mileage driven with cold start conditions. The function for cold start emission factors is ef_ldv_cold and its arguments are: args(ef_ldv_cold) ## function (v = &quot;LDV&quot;, ta, cc, f, eu, p, k = 1, show.equation = FALSE) ## NULL where: v: Category of vehicle: “LDV”. ta: Ambient temperature. Monthly mean can be used. cc: Size of engine in cc: “&lt;=1400”, “1400_2000” or “&gt;2000”. f: Type of fuel: “G”, “D” or “LPG”. eu: Euro standard: “PRE”, “I”, “II”, “III”, “IV”, “V”, “VI” or “VIc”. p: Pollutant: “CO”, “FC”, “NOx”, “HC” or “PM”. k: Multiplication factor. show.equation: Option to see or not the equation parameters. ef1 &lt;- ef_ldv_cold(ta = -5, cc = &quot;&lt;=1400&quot;, f =&quot;G&quot;, eu = &quot;I&quot;, p = &quot;CO&quot;) ef2 &lt;- ef_ldv_cold(ta = 0, cc = &quot;&lt;=1400&quot;, f =&quot;G&quot;, eu = &quot;I&quot;, p = &quot;CO&quot;) ef3 &lt;- ef_ldv_cold(ta = 5, cc = &quot;&lt;=1400&quot;, f =&quot;G&quot;, eu = &quot;I&quot;, p = &quot;CO&quot;) ef4 &lt;- ef_ldv_cold(ta = 10, cc = &quot;&lt;=1400&quot;, f =&quot;G&quot;, eu = &quot;I&quot;, p = &quot;CO&quot;) Figure 5.5: Cold Emission factor of PC CO (g/km) There is another function called ef_ldv_cold_list which will be deprecated soon. 5.5 Deterioration By default, VEIN includes deterioration factors from Copert (Ntziachristos and Samaras 2016). However, it is possible to include other sources, such as from (Corvalán and Vargas 2003) or include deteriorated local emission factors. This aspesct is faced in VEIN with the function emis_det. This function returns deteriorated factors, as numeric vectors, which must be multiplied with the emission factors of vehicles with 0 mileage. The arguments of this functions are: args(emis_det) ## function (po, cc, eu, km) ## NULL where: p: Pollutant. cc: Size of engine in cc. eu: Euro standard: “PRE”, “I”, “II”, “III”, “III”, “IV”, “V”, “VI”. km: mileage in km. VEIN includes a dataset of mileage function named “fkm”. data(fe2015) data(fkm) pckma &lt;- cumsum(fkm$KM_PC_E25(1:24)) #only vehicles with catalizer x1 &lt;- fe2015[fe2015$Pollutant == &quot;CO&quot;, ] x1E3 &lt;- subset(x1, x1$Euro_LDV %in% c(&quot;III&quot;, &quot;IV&quot;, &quot;V&quot;))$PC_G x1E1 &lt;- subset(x1, x1$Euro_LDV %in% c(&quot;I&quot;, &quot;II&quot;))$PC_G det_E3 &lt;- emis_det(po = &quot;CO&quot;, cc = 1000, eu = &quot;III&quot;, km = pckma[1:length(x1E3)]) det_E1 &lt;- emis_det(po = &quot;CO&quot;, cc = 1000, eu = &quot;III&quot;, km = pckma[(length(x1E3) + 1):23 ]) original_EF &lt;- x1$PC deteriorated_EF &lt;- x1$PC * c(det_E3, det_E1, rep(1, 13)) plot(x = 1:36, y = original_EF, type = &quot;b&quot;, pch = 15, col = &quot;blue&quot;, ylab = &quot;CO[g/km]&quot;, xlab = &quot;Age of use&quot;) # main = &quot;Deteriorated (red) and not-deteriorated (blue) EF CO&quot;) lines(x = 1:36, y = deteriorated_EF, type = &quot;b&quot;, pch = 16, col = &quot;red&quot;) Figure 5.6: Deteriorated (red) and not-deteriorated (blue) EF CO 5.6 Evaporative emissions ef_evap Evaporative emissions are important sources of hydrocarbons and these emissions are produced by vaporization of fuel due to variations in ambient temperatures (Mellios and Ntziachristos 2016, Andrade et al. (2017)). There are three types of emissions: diurnal emissions, due to increases in atmospheric temperature, which lead to thermal expansion of vapor fuel inside the tank; running losses, when the fuel evaporates inside the tank due to normal operation of the vehicle; and hot soak emissions, which occur when the hot engine is turned off. These methods implemented in VEIN were sourced from the evaporative emissions methods of Copert Tier 2 (Mellios and Ntziachristos 2016). In VEIN it is also possible to use local emission factors. Here I’m showing both approaches: Tier 2 copert approach \\[\\begin{equation} EV_{j,k} =\\sum_{s}D_{s} \\cdot \\sum_{j}F_{j} \\cdot (HS_{j,k}+de_{j,k}+RL_{j,k}) \\tag{5.4} \\end{equation}\\] where \\(EV_{j}\\) are the volatile organic compounds (VOC) evaporative emissions due to each type of vehicle \\(j\\). \\(D_s\\) is the “seasonal days” or number of days when the mean monthly temperature is within a determined range: [-5\\(^{\\circ}\\),10\\(^{\\circ}\\)C], [0\\(^{\\circ}\\), 15\\(^{\\circ}\\)C], [10\\(^{\\circ}\\), 25\\(^{\\circ}\\)C] and [20\\(^{\\circ}\\), 35\\(^{\\circ}\\)C]. \\(F_{j,k}\\) is the number of vehicles according to the same type \\(j\\) and age of use \\(k\\). \\(HS_{j,k}\\), \\(de_{j,k}\\) and \\(RL_{j,k}\\) are average hot/warm soak, diurnal and running losses evaporative emissions (\\(\\mathrm{g \\cdot day^{-1}}\\)), respectively, according to the vehicle type \\(j\\) and age of use \\(k\\). \\(HS_{j,k}\\) and \\(RL_{j,k}\\) are obtained using equations also sourced from (Mellios and Ntziachristos 2016): \\[\\begin{equation} HS_{j,k} = x_{j,k} \\cdot (c \\cdot (p \\cdot e_{shc}+(1-p) \\cdot e_{swc})+(1-c) \\cdot e_{shfi} ) \\tag{5.5} \\end{equation}\\] where: \\(x\\) is the number of trips per day for the vehicular type \\(j\\) and age of use \\(k\\). \\(c\\) is the fraction of vehicles with fuel return systems. \\(p\\) is the fraction of trips finished with hot engine, for example, an engine that has reached its normal operating temperature and the catalyst has reached its light-off temperature (Ntziachristos and Samaras 2016). The light-off temperature is the temperature at the point when catalytic reactions occur inside a catalytic converter. \\(e_{shc}\\) and \\(e_{swc}\\) are average hot-soak and warm-soak emission factors for gasoline vehicles with carburettor or fuel return systems (\\(\\mathrm{g \\cdot parking^{-1}}\\)). \\(e_{shfi}\\) is the average hot-soak emission factors for gasoline vehicles equipped with fuel injection and non-return fuel systems (\\(\\mathrm{g \\cdot parking^{-1}}\\)). The Eq. (5.6) shows the procedure. \\[\\begin{equation} RL_{j,k} = x_{j,k} \\cdot (c \\cdot (p \\cdot e_{rhc}+(1-p) \\cdot e_{rwc})+(1-c) \\cdot e_{rhfi} ) \\tag{5.6} \\end{equation}\\] where: \\(x\\) and \\(p\\) have the same meanings of Eq. (5.5). \\(e_{rhc}\\) and \\(e_{rwc}\\) are average hot and warm running losses emission factors for gasoline vehicles with carburettor or fuel return systems (\\(\\mathrm{g \\cdot trip^{-1}}\\)) \\(e_{rhfi}\\) are average hot running losses emission factors for gasoline vehicles equipped withfuel injection and non-return fuel systems (\\(\\mathrm{g \\cdot trip^{-1}}\\)). It is recommended to estimate the number of trips per day (Mellios and Ntziachristos 2016), \\(x\\), as the division between the mileage and 365 times the length of trip: \\(x = \\frac{mileage_j}{(365 \\cdot ltrip)}\\). However, the mileage of a vehicle is not constant throughout the years. Therefore, VEIN incorporates a dataset of equations to estimate mileage of different types of vehicles by age of use (Bruni and Bales 2013). The function for evaporative emission factors is ef_evap and it arguments are : args(ef_evap) ## function (ef, v, cc, dt, ca, k = 1, show = FALSE) ## NULL where: - ef: Name of evaporative emission factor as eshotc (\\(g \\cdot proced^-1\\)): mean hot-soak with carburator, eswarmc (\\(g \\cdot proced^-1\\)): mean cold and warm-soak with carburator, eshotfi: mean hot-soak with fuel injection, erhotc (\\(g \\cdot trip^-1\\)): mean hot running losses with carburator, erwarmc (\\(g \\cdot trip^-1\\)) mean cold and warm running losses, erhotfi (\\(g \\cdot trip^-1\\)) mean hot running losses with fuel injection. - v: Type of vehicles, “PC”, “Motorcycles”, “Motorcycles_2S” and “Moped” - cc: Size of engine in cc. PC “&lt;=1400”, “1400_2000” and “2000” Motorcycles_2S: “&lt;=50”. Motorcyces: “&gt;50”, “&lt;250”, “250_750” and “&gt;750” - dt: Average daily temperature variation: “-5_10”, “0_15”, “10_25” and “20_35” - ca: Size of canister: “no” meaning no canister, “small”, “medium” and “large” - k: multiplication factor - show: when TRUE shows row of table with respective emission factor. Example: library(vein) library(ggplot2) library(cptcity) dt &lt;- c(&quot;-5_10&quot;, &quot;0_15&quot;, &quot;10_25&quot;, &quot;20_35&quot;) ef &lt;- sapply(1:4, function(i){ ef_evap(ef = &quot;erhotc&quot;,v = &quot;PC&quot;, cc = &quot;&lt;=1400&quot;, dt = dt[i], ca = &quot;no&quot;, show = TRUE) }) ## ef units veh cc dt canister g ## 28 erhotc g/trip PC &lt;=1400 -5_10 no 1.67 ## ef units veh cc dt canister g ## 21 erhotc g/trip PC &lt;=1400 0_15 no 2.39 ## ef units veh cc dt canister g ## 14 erhotc g/trip PC &lt;=1400 10_25 no 3.25 ## ef units veh cc dt canister g ## 7 erhotc g/trip PC &lt;=1400 20_35 no 5.42 df &lt;- data.frame(ef = ef, temp = c(0, 10, 20, 30)) source(&quot;theme_black.R&quot;) ggplot(df, aes(x = temp, y = ef)) + geom_bar(stat = &quot;identity&quot;, fill = cpt(n = 4), col = &quot;white&quot;) + labs(x = &quot;Temperature[C]&quot;, y = &quot;RL Evaporative NMHC [g/trip]&quot;) + theme_black() Figure 5.7: Running losses evaporative emission actors (g/trip) Alternative approach The evaporative emission factors mentioned before are suitable for top-down estimations. That approach also requires knowledge of the ‘procedure’ and ‘trips’. In this section it is introduced an alternative which consists in transform the emission factors into \\(g \\cdot km^-1\\) and then do a bottom-up estimation. In order to do that, we need to follow some assumptions. First, we consider that the number of procedures is equal to trips. Then we estimate how many trips per day are produced each day and then we estimate how many kilometers are driven each day and convert these to emission factors as shown on Eq. (5.7). \\[\\begin{equation} EF_{ev}(\\frac{g}{km})=EF(_{ev})(\\frac{g}{trip}) \\cdot A(\\frac{trips}{day}) \\cdot B(\\frac{km}{day})^{-1} \\tag{5.7} \\end{equation}\\] Clearly, we need to know A \\((\\frac{trips}{day})\\) and B\\((\\frac{km}{day})^{-1}\\). Diurnal evaporative emissions factors are expressed as \\((\\frac{g}{day})\\). To convert to \\((\\frac{g}{km})\\) we only need the kilometers driven each day \\(\\frac{km}{day}^{-1}\\). Now, it will be shown an example with the evaporative emission factors from CETESB (2015). These emission factors are based on the methodology Tier 2 from -@Mellios and Ntziachristos (2016). If we consider evaporative emission factors of Passenger Cars using Gasoline (blended with 25% of Ethanol) (CETESB 2015) and 4.6 \\((\\frac{trips}{day})\\) (Ibarra-Espinosa 2017). ## year ed_20_35 eshot_20_35 erhot_20_35 ## 1 2015 0.06 0.09 0.03 ## 2 2014 0.10 0.10 0.04 ## 3 2013 0.12 0.13 0.05 ## 4 2012 0.19 0.16 0.06 ## 5 2011 0.19 0.17 0.14 ## 6 2010 0.08 0.08 0.06 The variable ed_20_35 are diurnal evaporative emission factors in \\(g \\cdot day^{-1}\\) and eshot_20_35 and erhot_20_35 \\(g \\cdot trip^{-1}\\). library(vein) data(fkm) evap$ed_20_35_gkm &lt;- evap$ed_20_35 / fkm$KM_PC_E25(1:41)/365 evap$eshot_20_35_gkm &lt;- evap$eshot_20_35 * 4.6/ fkm$KM_PC_E25(1:41)/365 evap$erhot_20_35_gkm &lt;- evap$erhot_20_35 * 4.6/ fkm$KM_PC_E25(1:41)/365 plot(x = 1:41, y = evap$eshot_20_35_gkm, col = &quot;blue&quot;, type = &quot;b&quot;, pch = 16, xlab = &quot;Age of use&quot;, ylab = &quot;EV NMHC [g/km]&quot;) lines(x = 1:41, y = evap$ed_20_35_gkm, col = &quot;red&quot;, type = &quot;b&quot;, pch = 15) lines(x = 1:41, y = evap$erhot_20_35_gkm, col = &quot;green&quot;, type = &quot;b&quot;, pch = 17) Figure 5.8: Hot Soak (blue), Diurnal (green) and Running Losses (red) EF (g/km) 5.7 Emission factors of wear ef_wear Wear emissions are very important because they contribute with an important fraction of PM from tyre and break wear. VEIN includes these functions from Ntziachristos and Boulter (2009) which include wear emission factors form tyre, break and road abrasion. The arguments are: args(ef_wear) ## function (wear, type, pol = &quot;TSP&quot;, speed, load = 0.5, axle = 2) ## NULL wear: Character; type of wear: “tyre”, “break” and “road” type: Character; type of vehicle: “2W”, “PC”, “LCV”, ’HDV&quot; pol: Character; pollutant: “TSP”, “PM10”, “PM2.5”, “PM1” and “PM0.1” speed: List of speeds load: Load of the HDV axle: Number of axle of the HDV library(vein) ?ef_wear 5.8 Emission factors from tunnel studies With VEIN you can choose three type of emissions factors, speed functions, local emission factors or scaled factors. In this section I will show how to expand the use of local emission factors considering tunnel emission factors (Pérez-Martinez et al. 2014), from the International Vehicle Emissions (IVE) Model (Davis et al. 2005) applied in Colombia (González et al. 2017). Pérez-Martinez et al. (2014) measured air pollutant concentrations in two tunnels in São Paulo city, one with predominant use of LDV vehicles and another with more HDV. The resulting emission factors for the fleet are shown on Table 5.2. Table 5.2: Emission factors from tunnels in São Paulo 2014 CO NOx LDV 5.8 [g/km] 0.3 [g/km] HDV 3.6 [g/km] 9.2 [g/km] If we want to compare these with the CETESB (2015) emission factors, we would have to weight these factors with the fleet. The weight mean emission factor of CO and Passenger Cars (PC) is 1.40 \\(g \\cdot km^{-1}\\) and for Light Trucks (LT) is 0.60 \\(g \\cdot km^{-1}\\). In the case of NOx, Passenger Cars (PC) is 0.16 \\(g \\cdot km^{-1}\\) and for Light Trucks (LT) is 3.24 \\(g \\cdot km^{-1}\\). The emission factors from the example are for vehicles with 0 kilometers without deterioration. Anyways, tunnel emission factors are higher that the weighted emission factors from CETESB. library(vein) data(fe2015) fecoPC &lt;- fe2015[fe2015$Pollutant == &quot;CO&quot;, &quot;PC_G&quot;] fecoLT &lt;- fe2015[fe2015$Pollutant == &quot;CO&quot;, &quot;LT&quot;] fenoxPC &lt;- fe2015[fe2015$Pollutant == &quot;NOx&quot;, &quot;PC_G&quot;] fenoxLT &lt;- fe2015[fe2015$Pollutant == &quot;NOx&quot;, &quot;LT&quot;] PC &lt;- age_ldv(x = 1, name = &quot;PC&quot;, agemax = 36, message = FALSE) LT &lt;- age_hdv(x = 1, name = &quot;LT&quot;, agemax = 36, message = FALSE) weighted.mean(fecoPC, PC) # PC CO ## [1] 1.40355 weighted.mean(fecoLT, LT) # LT CO ## [1] 0.5971173 weighted.mean(fenoxPC, PC) # PC NOx ## [1] 0.1699646 weighted.mean(fenoxLT, LT) # LT NOx ## [1] 3.241522 If the user wants to use tunnel emission factors from Pérez-Martinez et al. (2014) in VEIN, the user would have to use the same value for all respective categories of the vehicular composition. For instance, after running inventory, include tunnel emission factors in each *input.R. 5.9 Emission factors from International Vehicle Emissions (IVE) The IVE model is calculates emission factors by correcting BASE emission factors with the vehicle specific power (VSP) methodology to predict emissions (Jimenez et al. 1999). The formula is shown on Eq. (5.8). \\[\\begin{equation} VSP = v \\cdot (1.1 \\cdot a + 9.81(atan(sin(grade))) + 0.132) + 0.000302v^3 \\tag{5.8} \\end{equation}\\] where: \\(v\\) is velocity \\((m \\cdot s^{-1})\\), \\(a\\) is the second by second acceleration \\((m \\cdot s^{-2})\\) and grade the second by second change in height defined as \\(\\frac{(h_{t=0} - h_{t=-1})}{v}\\); being \\(h\\) as altitude \\(m\\). This method requires that the user measures the activity Global Position System (GPS) recordings second by second and/or emissions measurements with Portable Emissions Measurement Systems (PEMS). González et al. (2017) measure the vehicular activity in the city of Manizales, Colombia. In this case, there were no PEMS measurements, but IVE allows to produce emission factors from the GPS recordings based on Mobile EPA emissions model(Arbor 2003, Davis et al. (2005)). The arguments are: args(ef_ive) ## function (description = &quot;Auto/Sml Truck&quot;, fuel = &quot;Petrol&quot;, weight = &quot;Light&quot;, ## air_fuel_control = &quot;Carburetor&quot;, exhaust = &quot;None&quot;, evaporative = &quot;PCV&quot;, ## mileage, pol, details = FALSE) ## NULL description: Character; “Auto/Sml Truck” “Truck/Bus” or“Sml Engine”. fuel: Character; “Petrol”, “NG Retrofit”, “Natural Gas”, “Prop Retro.”, “Propane”, “EthOH Retrofit”, “OEM Ethanol”, “Diesel”, “Ethanol” or “CNG/LPG”. weight: Character; “Light”, “Medium”, “Heavy”, “Lt”, “Med” or “Hvy” air_fuel_control: Character; One of the following characters: “Carburetor”, “Single-Pt FI”, “Multi-Pt FI”, “Carb/Mixer”, “FI”, “Pre-Chamber Inject.”, “Direct Injection”, “2-Cycle”, “2-Cycle, FI”, “4-Cycle, Carb”, “4-Cycle, FI” “4-Cycle” exhaust: Character: “None”, “2-Way”, “2-Way/EGR”, “3-Way”, “3-Way/EGR”, “None/EGR”, “LEV”, “ULEV”, “SULEV”, “EuroI”, “EuroII”, “EuroIII”, “EuroIV”, “Hybrid”, “Improved”, “EGR+Improv”, “Particulate”, “Particulate/NOx”, “EuroV”, “High Tech” or “Catalyst” evaporative: Character: “PCV”, “PCV/Tank” or“None”. mileage:Numeric; mileage of vehicle by age of use km. pol: Character: “VOC_gkm”, “CO_gkm”, “NOx_gkm”, “PM_gkm”, “Pb_gkm”, “SO2_gkm”, “NH3_gkm”, “ONE_3_butadiene_gkm”, “formaldehyde_gkm”, “acetaldehyde_gkm”, “benzene_gkm”, “EVAP_gkm”, “CO2_gkm”, “N20_gkm”, “CH4_gkm”, “VOC_gstart”, “CO_gstart”, “NOx_gstart”, “PM_gstart”, “Pb_gstart”, “SO2_gstart”, “NH3_gstart”, “ONE_3butadiene_gstart”, “formaldehyde_gstart”,“acetaldehyde_gstart”, “benzene_gstart”, “EVAP_gstart”, “CO2_gstart”, “N20_gstart”, “CH4_gstart” details: Logical; option to see or not more information about vehicle. 5.10 Emission factors from the Environmental Agency of São Paulo It has been mentioned that the model includes already some emission factors from the Environmental Agency of São Paulo CETESB for year 2015. However, a new feature alredy present in VEIN is incorporation of all CETESB emission factors for 2016 (CETESB 2016). args(ef_cetesb) ## function (p, veh, full = FALSE) ## NULL p: Character; Pollutants: “COd”, “HCd”, “NMHCd”, “CH4”, “NOxd”, “CO2” “PM”, “N2O”, “KML”, “FC”, “NO2d”, “NOd”, “gD/KWH”, “gCO2/KWH”, “RCHOd”, “CO”, “HC”, “NMHC”, “NOx”, “NO2” ,“NO”, “RCHO” (g/km). The letter ‘d’ means deteriorated factor. Also, evaporative emissions at average temperature ranges: “D_20_35”, “S_20_35”, “R_20_35”, “D_10_25”, “S_10_25”, “R_10_25”, “D_0_15” “S_0_15” and “R_0_15” where D means diurnal (g/day), S hot/warm soak (g/trip) and R hot/warm running losses (g/trip). veh: Character; Vehicle categories: “PC_G”, “PC_FG”, “PC_FE”, “PC_E” “LCV_G”, “LCV_FG”, “LCV_FE”, “LCV_E”, “LCV_D”, “SLT”, “LT”, “MT”, “SHT” “HT”, “UB”, “SUB”, “COACH”, “ARTIC”, “M_G_150”, “M_G_150_500”, “M_G_500” “M_FG_150”, “M_FG_150_500”, “M_FG_500”. “M_FE_150”, “M_FE_150_500”, “M_FE_500”, “CICLOMOTOR”, “GNV full Logical; To return a data.frame instead or a vector adding Age, Year, Brazilian emissions standards and its euro equivalents. The letter ‘d’ means deteriorated factor. I added the pollutants “NO”, “NO2” based on the speciation of the Ntziachristos and Samaras (2016) guidelines. I also added the categiry “ARTIC” for articulated buses, based on the proportion of Articulated buses to standard urban buses on Ntziachristos and Samaras (2016) guidelines, which is apporximatly 1.4 times the standard emission factor. Appendix B "],
["est.html", "Chapter 6 Estimation of emissions 6.1 The emis function 6.2 The emis_cold function 6.3 The emis_evap function 6.4 The emis_paved function 6.5 The emis_wear function", " Chapter 6 Estimation of emissions The emissions estimation process was shown on Eq. (5.1) on chapter 5. In this equation, it was shown that how the emissions are obtained by multiplying the traffifc flow with the distance that each car travels (length of the road if it is a road network), and emissions and deterioration factors. In this chapter I will show how VEIN interprets this and other emission equations to estimate emissions. At the end of each section The Fig. 6.1 showsa diagram with the estimation process. The pink boxes hows VEIN classes, the circle data and the grey boxes functions. The object Vehicles is a class consisting in a matrix of vehicles with untis \\(1 \\cdot h^{-1}\\), as shown on chapter 4, however, the units in Vehicles is not a requirement for estimating emissions. The object of class Speed is a matrix of speeds with the number of columns as the calculated speeds at different hours at each row. This object can be present or not, depending on the type of emission factor considered, for instant, emission factors not depending on speed. The object class of EmissionFactorsList are list of functions depending on speed as \\(f(V)\\). Each function can depend on speed or not as shown on chapter 5, section 5.2. Lastly, the object lkm is the length of the road expressed in \\(lkm\\). The function emis reads the inputs and estimates the emissions producing an object with class EmissionsArray which has 4 dimensions, number of streets, ages of use of vehicle, number of hours and number of days. Figure 6.1: Emissions estimation process with VEIN The estimation process is done with the emissions functions. The emissions estimations functions are: emis for hot emissions, emis_cold for cold start emissions, emis_evap for evaporative emissions, emis_paved for resuspension emissions on paved roads, and emis_wear for wear of breakes, tyres and roads. These functions perform internal checks for ensuring that the length lkm has the unit of \\(km\\). This means that, if lkm has units different than \\(km\\), the function will not run. These function runs internally lapply which are faster for written in C. Despite that these functions are fast, i will try to make them faster with some RCPP implementation in future. 6.1 The emis function The arguments of emis are: args(vein::emis) ## function (veh, lkm, ef, speed = 34, agemax = ifelse(is.data.frame(veh), ## ncol(veh), ncol(veh[[1]])), profile, hour = nrow(profile), ## day = ncol(profile), array = T) ## NULL veh: “Vehicles” data-frame or list of “Vehicles” data-frame. Each data-frame has number of columns matching the age distribution of that type of vehicle. The number of rows is equal to the number of streets link. lkm: Length of each link that must in \\(km\\). As consequence, emission factors must be in \\(g \\cdot km^{-1}\\). ef: “EmissionFactorsList”. A list of emission factors as speed functions. Each element has the form \\(f(V)\\). The implicit unit is \\(g \\cdot km^{-1}\\). speed: “Speed” object. A Speed data-frame with number of columns as hours. agemax: Age of oldest vehicles of the vehicles veh. The information of this argument can be obtained from the veh argument Therefore, this argument will be deprecated. profile: Numerical or dataframe or matrix with nrows equal to the hours and cols to each day. This is traffic data normalized to the hour of the input traffic data. hour: Number of considered hours in estimation. As this information can be derived form the argument profile, the default value is the number of rows of the matrix profile. day: Number of considered days in estimation. As this information can be derived form the argument profile, the default value is the number of coluns of the matrix profile. array: When FALSE produces a dataframe of the estimation. When TRUE expects a profile as a dataframe producing an array with dimensions (streets x columns x hours x days) When the only arguments present in the function are veh, lkm and ef assumes a top-down and shows a message. 6.2 The emis_cold function The arguments of emis_cold are: args(vein::emis_cold) ## function (veh, lkm, ef, efcold, beta, speed = 34, agemax = if (!inherits(x = veh, ## what = &quot;list&quot;)) { ## ncol(veh) ## } else { ## ncol(veh[[1]]) ## }, profile, hour = nrow(profile), day = ncol(profile), array = TRUE) ## NULL The arguments are similar with emis with the difference that it is added two arguments: efcold: List of functions of cold start emission factors of vehicular categories. Technically, each function is also of the form \\(f(V)\\). beta: Datraframe with the hourly cold-start distribution to each day of the period. Number of rows are hours and columns are days. It represents the fraction of mileage driven under cold-start conditions. The equation for estimating cold-start emissions is on Eq. (5.3). 6.3 The emis_evap function The estimation of evaporative emissions applies Tier 2 from Mellios and Ntziachristos (2016). The approach followed in VEIN was very simply, consisting in only adding elements of a data-frame. args(vein::emis_evap) ## function (veh, name, size, fuel, aged, nd4, nd3, nd2, nd1, hs_nd4, ## hs_nd3, hs_nd2, hs_nd1, rl_nd4, rl_nd3, rl_nd2, rl_nd1, d_nd4, ## d_nd3, d_nd2, d_nd1) ## NULL veh: this are the number of vehicles at each age of use and for each street. It is a Vehicles object. name: Character indicating the name of the vehicle. size: Character indicating the size of the vehicle. fuel: Character indicating the fuel of the vehicle. age: Numeric vector with the age distribution, for instance, 1:40 for vehicles between 1 and 40 years of use. nd4: Number of days of your perdiof of study with monthly average temperature between 20 and 35 celcius degrees. If the period of time is a year, this is the annual number of days under that condition. nd3: Number of days of your perdiof of study with monthly average temperature between 10 and 25 celcius degrees. nd2: Number of days of your perdiof of study with monthly average temperature between 0 and 15 celcius degrees. nd1: Number of days of your perdiof of study with monthly average temperature between -5 and 10 celcius degrees. hs_nd4: Number of average daily hot-soak evaporative emissions for days with temperature between 20 and 35 celcius degrees hs_nd3: Number of average daily hot-soak evaporative emissions for days with temperature between 10 and 25 celcius degrees hs_nd2: Number of average daily hot-soak evaporative emissions for days with temperature between 0 and 15 celcius degrees hs_nd1: Number of average daily hot-soak evaporative emissions for days with temperature between -5 and 10 celcius degrees rl_nd4: Number of average daily running losses evaporative emissions for days with temperature between 20 and 35 celcius degrees rl_nd3: Number of average daily running losses evaporative emissions for days with temperature between 10 and 25 celcius degrees rl_nd2: Number of average daily running losses evaporative emissions for days with temperature between 0 and 15 celcius degrees rl_nd1: Number of average daily running losses evaporative emissions for days with temperature between -5 and 10 celcius degrees d_nd4: Number of average daily diurnal evaporative emissions for days with temperature between 20 and 35 celcius degrees d_nd3: Number of average daily diurnal evaporative emissions for days with temperature between 10 and 25 celcius degrees d_nd2: Number of average daily diurnal evaporative emissions for days with temperature between 0 and 15 celcius degrees d_nd1: Number of average daily diurnal evaporative emissions for days with temperature between -5 and 10 celcius degrees 6.4 The emis_paved function Evaporative emissions are emissions of resuspended dust due to traffic circulating ober paved or non-paved roads. These emissions can be an important source of mass particulate matter, and several cities programs that aims to improve air quality by diminishing these emissions (Amato et al. 2010). However, these emissions are not considered by in the European emissions guidelines, where their focus is on primary particles and not those resulting from the resuspension of previously deposited material (Ntziachristos and Boulter 2009). The method adopted in VEIN comes from the USEPA (USA-EPA 2016) which presents equations for annual, daily and hourly estimations: \\[\\begin{equation} EF_{paved}=k \\cdot sL^{0.91} \\cdot W^{1.02} \\tag{6.1} \\end{equation}\\] Where \\(EF_{paved}\\) is the emission factor of particulate matter. \\(k\\) particle size splitter. \\(sL\\) road surface silt loading \\(g \\cdot m^{-2}\\). \\(W\\) average weight. Equation (6.1) can be extrapolated to consider natural mitigation of rainy periods of time with daily basis: \\[\\begin{equation} EF_{anual} = EF_{paved} \\cdot (1 - \\frac{P}{4 \\cdot N}) \\tag{6.2} \\end{equation}\\] Where \\(EF_{anual}\\) anual or long term emission factor. \\(P\\) number of days with accumulated rain above 0.254 mm. \\(N\\) total number of days. or hourly \\[\\begin{equation} EF_{hourly} = EF_{paved} \\cdot (1 - \\frac{1.2 \\cdot P}{N}) \\tag{6.2} \\end{equation}\\] Where \\(EF_{annual}\\) annual or long term emission factor. \\(P\\) number of hours with accumulated rain above 0.254 mm. \\(N\\) total number of hours. For instance, 8760 for 1 year. The function emis_paved has the arguments: args(vein::emis_paved) ## function (veh, lkm, k = 0.62, sL1 = 0.6, sL2 = 0.2, sL3 = 0.06, ## sL4 = 0.03, W) ## NULL Where, -veh: It is an array with dimenssions number of streets x hours of day x days of week. - lkm: Length of each link. - k: K_PM30 = 3.23, K_PM15 = 0.77, K_PM10 = 0.62 and K_PM2.5 = 0.15. - sL1: Silt loading (g/m2) for roads with ADT &lt;= 500. - sL2: Silt loading (g/m2) for roads with ADT &gt; 500 and &lt;= 5000. - sL3: Silt loading (g/m2) for roads with ADT &gt; 5000 and &lt;= 1000. - sL4: Silt loading (g/m2) for roads with ADT &gt; 10000. - W: array of dimensions of veh. It consists in the hourly averaged weight of traffic fleet in each road. For instance, Lets create an array of vehicles. The funcion adt calculates the amount pf vehicles at all hours. Lets use the data(net) asumming no buses. Let’s calculate the total traffic for only 24 hours with the same profile. For simplicity, let’s assume that all vehicle are expressed in vehicle equivalent and it is a dry period. library(vein) data(net) data(profiles) vkpc &lt;- vkm(net$ldv*0.75, 1, matrix(profiles$PC_JUNE_2012[, 1])) vklcv &lt;- vkm(net$ldv*0.1, 1, matrix(profiles$LCV_JUNE_2012[, 1])) vkmc &lt;- vkm(net$ldv*0.15, 1, matrix(profiles$MC_JUNE_2012[, 1])) vkhgv &lt;- vkm(net$hdv, 1, matrix(profiles$HGV_JUNE_2012[, 1])) vk &lt;- vkpc + vklcv + vkmc + vkhgv dim(vk) ## [1] 1505 24 W is the average hourly fleet weight. It ahs the same dimensions of adt2. Let’s assume an individual weight of PC is 1, LCV 1.5, HGV = 10 and MC 0.5. This example is a simplification, adt should be calculated with full characterization of the fleet. wpc &lt;- vkm(net$ldv*0.75, 1, profiles$PC_JUNE_2012[, 1])*1 wlcv &lt;- vkm(net$ldv*0.1, 1, profiles$LCV_JUNE_2012[, 1])*1.5 wmc &lt;- vkm(net$ldv*0.15, 1, profiles$MC_JUNE_2012[, 1])*0.5 whgv &lt;- vkm(net$hdv, 1, profiles$HGV_JUNE_2012[, 1])*10 W &lt;- (wpc + wlcv + wmc + whgv)/vk W[is.na(W)] &lt;- 0 dim(W) ## [1] 1505 24 and now we estimate the emissions with the default values form PM10. emi &lt;- emis_paved(veh = vk, lkm = net$lkm, W = W) emi[1:4, 1:4] ## Result for Emissions ## h1 h2 h3 h4 ## 1 28.492378 [g/h] 41.326236 [g/h] 27.987685 [g/h] 30.978253 [g/h] ## 2 48.704190 [g/h] 31.257192 [g/h] 27.139666 [g/h] 34.919757 [g/h] ## 3 4.360828 [g/h] 2.327479 [g/h] 1.576257 [g/h] 1.744684 [g/h] ## 4 10.371056 [g/h] 5.535283 [g/h] 3.748702 [g/h] 4.149262 [g/h] 6.5 The emis_wear function Wear emissions can be very important, in fact, these are second most important source of particulate matter in Europe (Lükewille, Tista, and Hoenders 2017). These methods in VEIN comes from Ntziachristos and Boulter (2009) which include wear of “tyre”, “break” and “road”. The arguments of the function emis_wear are: args(vein::emis_wear) ## function (veh, lkm, ef, what = &quot;tyre&quot;, speed, agemax = ncol(veh), ## profile, hour = nrow(profile), day = ncol(profile)) ## NULL Where, veh: Object of class “Vehicles”. lkm: Length of the road. ef: list of emission factor functions class “EmissionFactorsList”, length equals to hours. agemax: Age of oldest vehicles for that category profile: Dataframe or matrix with nrows equal to hours and ncol as days of the week hour: Number of considered hours in estimation, with default value as number of rows of profile. day: Number of considered days in estimation, with default value as number of columns of profile. Let’s estimate wear emissions! First, we get the emission factor with the ef_wear function: library(vein) data(net) data(profiles) pro &lt;- profiles$PC_JUNE_2012[, 1] # 24 hours pc_week &lt;- temp_fact(net$ldv+net$hdv, pro) df &lt;- netspeed(pc_week, net$ps, net$ffs, net$capacity, net$lkm, alpha = 1) ef &lt;- ef_wear(wear = &quot;tyre&quot;, type = &quot;PC&quot;, pol = &quot;PM10&quot;, speed = df) Then we estimate emissions emi &lt;- emis_wear(veh = age_ldv(net$ldv, name = &quot;VEH&quot;), speed = df, lkm = net$lkm, ef = ef, profile = pro) ## Average age of VEH is 11.17 ## Number of VEH is 1946.95 * 10^3 veh df &lt;- emis_post(emi, pollutant = &quot;PM&quot;, by = &quot;streets_wide&quot;) df[1:4, 1:4] ## Result for Emissions ## V1 V2 V3 V4 ## 1 2.0689049 [g/h] 1.0160833 [g/h] 0.56468672 [g/h] 0.52486176 [g/h] ## 2 0.7614073 [g/h] 0.3743085 [g/h] 0.20803274 [g/h] 0.19336135 [g/h] ## 3 0.1116298 [g/h] 0.0548773 [g/h] 0.03049965 [g/h] 0.02834868 [g/h] ## 4 0.2768287 [g/h] 0.1360872 [g/h] 0.07563435 [g/h] 0.07030028 [g/h] Appendix B "],
["post.html", "Chapter 7 Post estimation with emis_post 7.1 Emissions by street 7.2 Total emissions in data-frames 7.3 Merging emissions 7.4 Creating grids 7.5 Gridding bottom-up emissions with emis_grid 7.6 Gridding top-down emissions with emis_dist 7.7 Gridding top-down emissions with grid_emis", " Chapter 7 Post estimation with emis_post Once the emissions are estimated we obtained EmissionsArray objects, which as mentioned before, they are arrays with the dimensions streets x age distribution of vehicles x hours x days. Figure 7.1: Post-emissions Now the function emis_post reads the EmissionsArray and and convert it to data-frames that are easier to manage. The arguments of emis_post are: args(vein::emis_post) ## function (arra, veh, size, fuel, pollutant, by = &quot;veh&quot;, net) ## NULL Where, arra: EmissionsArray obtained with the emis functions. It is an array of emissions 4d: streets x category of vehicles x hours x days or 3d: streets x category of vehicles x hours veh: Character indicating the type of vehicle , for instance: “PC”. size: Character indicating the size or weight, for instance: “&lt;1400”, “1400&lt;cc&lt;2000”, “GLP”, “Diesel”. fuel: Character indicating fuel, for instance: “Gasoline”, “E_25”, “GLP”, “Diesel”. pollutant: Character indicating the pollutant, for instance “CO”, “NOx”, etc. by: Character indicating type of output, “veh” for total vehicular category , “streets_narrow” or “streets_wide”. This is the most important argument of this function. “streets_wide” returns a dataframe with rows as number of streets and columns the hours as days*hours considered, e.g. 168 columns as the hours of a whole week and “streets_wide repeats the row number of streets by hour and day of the week Lets create some objects 7.1 Emissions by street From previous chapters we worked with Vehicles, EmissionFactors and estimate emissions generating EmissionsArray. Now let’s create an EmissionsArray object. library(vein) library(veinreport) ## ## Attaching package: &#39;veinreport&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## theme_black library(cptcity) library(ggplot2) data(net) data(profiles) data(fe2015) PC_G &lt;- age_ldv(x = net$ldv, name = &quot;PC&quot;) ## Average age of PC is 11.17 ## Number of PC is 1946.95 * 10^3 veh # Estimation for 168 hour and local factors pcw &lt;- temp_fact(net$ldv, profiles$PC_JUNE_2014) # June is not holliday in southern hemisphere hdvw &lt;- temp_fact(net$hdv, profiles$HGV_JUNE_2014) speed &lt;- netspeed(pcw + hdvw, net$ps, net$ffs, net$capacity, net$lkm, alpha = 1) lef &lt;- EmissionFactorsList(fe2015[fe2015$Pollutant==&quot;CO&quot;, &quot;PC_G&quot;]) E_CO &lt;- emis(veh = PC_G,lkm = net$lkm, ef = lef, speed = speed, profile = profiles$PC_JUNE_2014) ## Number of columns of &#39;veh&#39; is different than length of &#39;ef&#39; ## adjusting length of ef to the number of colums of &#39;veh&#39; ## 187546.38 kg emissions in 24 hours and 7 days Now that we have our EmissionsArray E_CO, we can process it with the function emis_post. The emissions by street are obtained with the argument by = “streets_wide”: E_CO_STREETS &lt;- emis_post(E_CO, by = &quot;streets_wide&quot;) E_CO_STREETS[1:6, 1:3] ## Result for Emissions ## V1 V2 V3 ## 1 676.629408 [g/h] 349.068278 [g/h] 206.13032 [g/h] ## 2 259.924802 [g/h] 134.093349 [g/h] 79.18423 [g/h] ## 3 38.107534 [g/h] 19.659404 [g/h] 11.60919 [g/h] ## 4 90.628506 [g/h] 46.754599 [g/h] 27.60933 [g/h] ## 5 3.884417 [g/h] 2.003943 [g/h] 1.18336 [g/h] ## 6 378.775340 [g/h] 195.407492 [g/h] 115.39120 [g/h] In the version 0.3.17 it was added the capability of returning an spatial object class ‘sf’ with ‘LINESTRING’: E_CO_STREETS &lt;- emis_post(E_CO, by = &quot;streets_wide&quot;, net = net) class(E_CO_STREETS) ## [1] &quot;sf&quot; &quot;data.frame&quot; ggplot(E_CO_STREETS) + geom_sf(aes(colour = as.numeric(V9))) + scale_color_gradientn(colours = rev(cpt())) + theme_bw()+ ggtitle(&quot;CO emissions at 08:00 (g/h)&quot;) Figure 7.2: CO emisions of PC (g/h) Now, if we estimate the NOx emissions of Light Trucks we will a slight different pattern of emissions: LT &lt;- age_hdv(x = net$hdv, name = &quot;LT&quot;) ## Average age of LT is 17.12 ## Number of LT is 148.12 * 10^3 veh lef &lt;- EmissionFactorsList(fe2015[fe2015$Pollutant==&quot;NOx&quot;, &quot;LT&quot;]) E_NOx &lt;- emis(veh = LT, lkm = net$lkm, ef = lef, speed = speed, profile = profiles$PC_JUNE_2014) ## Number of columns of &#39;veh&#39; is different than length of &#39;ef&#39; ## adjusting length of ef to the number of colums of &#39;veh&#39; ## 34029.87 kg emissions in 24 hours and 7 days E_NOx_STREETS &lt;- emis_post(E_NOx, by = &quot;streets_wide&quot;, net = net) ggplot(E_NOx_STREETS) + geom_sf(aes(colour = as.numeric(V9))) + scale_color_gradientn(colours = rev(cpt())) + theme_bw()+ ggtitle(&quot;NOX emissions at 08:00 (g/h)&quot;) Figure 7.3: NOx emisions of LT (g/h) 7.2 Total emissions in data-frames In order to obtain the total emissions in data-frame, the same function emis_post is used, but in this case, with the argument by = “veh”. We also need to add arguments of veh for the type of vehicle, size the size or gross weight, fuel and pollutant. The argument net is not required in this case. E_NOx_DF &lt;- emis_post(arra = E_NOx, veh = &quot;LT&quot;, size = &quot;Small&quot;, fuel = &quot;B5&quot;, by = &quot;veh&quot;, pollutant = &quot;NOx&quot;) head(E_NOx_DF) ## E_NOx g veh size fuel pollutant age hour ## 1 E_NOx_1 182.5943 [g/h] LT Small B5 NOx 1 1 ## 2 E_NOx_2 163.2499 [g/h] LT Small B5 NOx 2 1 ## 3 E_NOx_3 177.5608 [g/h] LT Small B5 NOx 3 1 ## 4 E_NOx_4 208.5892 [g/h] LT Small B5 NOx 4 1 ## 5 E_NOx_5 765.7001 [g/h] LT Small B5 NOx 5 1 ## 6 E_NOx_6 885.6223 [g/h] LT Small B5 NOx 6 1 The resulting object is a data-frame with the name of the input array, then it has the g/h. Also, the name of the vehicle, the size, fuel, pollutant, age and hour. This is interesting because we can now what are the most pollutatn vehicle and at which hour this emissions ocurres. E_NOx_DF[E_NOx_DF$g == max(E_NOx_DF$g), ] ## E_NOx g veh size fuel pollutant age hour ## 517 E_NOx_17 29139.51 [g/h] LT Small B5 NOx 17 11 The highest emissions by hour are of Light Trucks of 17 years of use at hour 11 on local time. However, it is possible to get more interesting insights of the data. The datra can be aggregated by age, hour or plot all together as shown on Fig. 7.6. The highest emissions ocurre between 17 and 27 years of use. This figure also shows the effect of emissions standards introduced in different years. df &lt;- aggregate(E_NOx_DF$g, by = list(E_NOx_DF$hour), sum) plot(df, type = &quot;b&quot;, pch = 16, xlab = &quot;hour&quot;, ylab = &quot;NOx (g/h)&quot;) Figure 7.4: NOx emissions of LT by hour library(ggplot2) library(veinreport) # theme_black df &lt;- aggregate(E_NOx_DF$g, by = list(E_NOx_DF$age), sum) names(df) &lt;- c(&quot;Age&quot;, &quot;g&quot;) ggplot(df, aes(x = Age, y = as.numeric(g), fill = as.numeric(g))) + geom_bar(stat = &quot;identity&quot;) + scale_fill_gradientn(colours = cpt()) + theme_black() + labs(x = &quot;Age of use&quot;, y = &quot;NOx (g/h)&quot;) Figure 7.5: NOx emissions of LT by age library(ggplot2) library(veinreport) # theme_black ggplot(E_NOx_DF, aes(x = age, y = as.numeric(g), fill = hour)) + geom_bar(stat = &quot;identity&quot;) + scale_fill_gradientn(colours = cpt()) + theme_black() + labs(x = &quot;Age of use&quot;, y = &quot;NOx (g/h)&quot;) Figure 7.6: NOx emissions of LT 7.3 Merging emissions The function inventory was designed to store the emissions of each type of vehicle in each directory. Hence, it was necessary to create a function that read and merge the emissions that are in each directory, returning a data-frame os a spatial feature data-frame. The function is emis_merge. As it can be seen on Fig. 7.1, emis_merge comes after emis_post or speciate. The arguments of emis_merge are: args(vein::emis_merge) ## function (pol = &quot;CO&quot;, what = &quot;STREETS.rds&quot;, streets = T, net, ## path = &quot;emi&quot;, crs, under = &quot;after&quot;, ignore = FALSE, as_list = FALSE) ## NULL Where, pol: Character. Pollutant. what: Character. Word to search the emissions names, “STREETS”, “DF” or whatever name. It is important to include the extension .‘rds’ streets: Logical. If true, emis_merge will read the street emissions created with emis_post by “streets_wide”, returning an object with class ‘sf’. If false, it will read the emissions data-frame and rbind them. net: ‘Spatial feature’ or ‘SpatialLinesDataFrame’ with the streets. It is expected #‘that the number of rows is equal to the number of rows of street emissions. If #’ not, the function will stop. path: Character. Path where emissions are located crs: coordinate reference system in numeric format from http://spatialreference.org/ to transform/project spatial data using sf::st_transform In order to see how this functions works, let’s run the example in the inventory function. First, lets create a project, or in other words a directory named “YourCity”, into the temporary directory. In this part you can place your project wherever you want with the actual name of your city. Then run inventory with the default configuration. name = file.path(tempdir(), &quot;YourCity&quot;) vein::inventory(name = name) ## files at /tmp/RtmpAxG1On/YourCity ## Directories: ## [1] &quot;/tmp/RtmpAxG1On/YourCity&quot; ## [2] &quot;/tmp/RtmpAxG1On/YourCity/ef&quot; ## [3] &quot;/tmp/RtmpAxG1On/YourCity/emi&quot; ## [4] &quot;/tmp/RtmpAxG1On/YourCity/emi/BUS_01&quot; ## [5] &quot;/tmp/RtmpAxG1On/YourCity/emi/HGV_01&quot; ## [6] &quot;/tmp/RtmpAxG1On/YourCity/emi/LCV_01&quot; ## [7] &quot;/tmp/RtmpAxG1On/YourCity/emi/MC_01&quot; ## [8] &quot;/tmp/RtmpAxG1On/YourCity/emi/PC_01&quot; ## [9] &quot;/tmp/RtmpAxG1On/YourCity/est&quot; ## [10] &quot;/tmp/RtmpAxG1On/YourCity/images&quot; ## [11] &quot;/tmp/RtmpAxG1On/YourCity/network&quot; ## [12] &quot;/tmp/RtmpAxG1On/YourCity/post&quot; ## [13] &quot;/tmp/RtmpAxG1On/YourCity/post/df&quot; ## [14] &quot;/tmp/RtmpAxG1On/YourCity/post/grids&quot; ## [15] &quot;/tmp/RtmpAxG1On/YourCity/post/streets&quot; ## [16] &quot;/tmp/RtmpAxG1On/YourCity/profiles&quot; ## [17] &quot;/tmp/RtmpAxG1On/YourCity/veh&quot; In my case, the files are in directory /tmp/RtmpAxG1On/YourCity. Now, if you open the file file main.R, you will see: This script starts with setwd function, Then the first section is the network, where user reads and prepares the traffic information. Then the second section runs a script whichruns the age functions for the deault vehicular composition of the inventory function. The third section estimates the emissions by running each input.R file inside the directory est The fourth section, creates a grid and run the script post.R is shown below: The function emis_merge shown in line 2 is designed to read the all the files with names CO and the default argument what is “STREETS.rds”, for instance, PC_GASOLINE_CO_STREETS.rds. Hence, this function reads all the files under that condition. The other argument is streets with defailt value of TRUE, meaning that the function now knows that the resulting object must be an spatial network, and the net argument is already calling the net object part of the VEIN data, the function will merge all the objects summing the emissions of all vehicle street by street. The resulting object is a spatial “LINESTRING” class of sf. This function assumes that emissons files are data.frames and non tests have been made to see if this function would read work sf objects. On the other hand, the line 12 also runs all the emissions files whose names includes the word CO, but also including the words “DF.rds”, which are the files from emis_post with argument by equals to “veh”. In this case, it reads and merge the data-frames and prints the sum emissions by pollutant. If the user source he file main.R, it will calculate the emissions and produce some plots. source(paste0(name, &quot;/main.R&quot;)) 7.4 Creating grids Once we have processed our emissions array with emis_post and/or we have spatial emissions, we can then create grids and allocate our emissions into the grids. Lets check the function make_grid first: args(vein::make_grid) ## function (spobj, width, height = width, polygon, crs = 4326, ## ...) ## NULL This function originally used an sp approach. However, now uses an sf approach for creating the grid. Actually, the arguments are pretty much the same with the sf::st_make_grid with the exeption that is focused in returning polygons with coordinates at centroids of each cell. Therefore, the arguments height and polygon are deprecated. Lets create grid for our net. library(vein) library(sf) ## Linking to GEOS 3.6.2, GDAL 2.2.3, PROJ 4.9.3 data(net) net &lt;- st_transform(st_as_sf(net), 31983) g &lt;- make_grid(spobj = net, width = 500) ## Number of lon points: 23 ## Number of lat points: 21 class(g) ## [1] &quot;sf&quot; &quot;data.frame&quot; plot(g$geometry, axes = TRUE) plot(net$geometry, add = TRUE) Figure 7.7: Grid with spacing of 500 mts The class of net is SpatialLinesDataFrame, which is converted to sf. Then, as the coordinte reference system of net is WGS84 with epsg 4326, we are transforming to UTM to create a grid with grid spacing of 500 mts. The class of the grid object, g is “sf data.frame”. 7.5 Gridding bottom-up emissions with emis_grid The functionemis_grid allocates emissions proportionally to each grid cell. The process is performed by intersection between geometries and the grid. It means that requires “sr” according with your location for the projection. It is assumed that spobj is a spatial*DataFrame or an “sf” with the pollutants in data. This function return an object class “sf”. Before sf era, i tried to useraster::intersect which imports rgeos and took ages. Then I started to use QGIS Development Team (2017) (https://www.qgis.org), and later the R package Muenchow, Schratz, and Brenning (2018) which takes 10 minutes for allocating emissions of the mega-city of São Paulo and a grid spacing of 1 km. 10 min is not bad. However, when sf appeared and also, included the Spatial Indexes (https://www.r-spatial.org/r/2017/06/22/spatial-index.html), it changed the game. A new era started. It took 5.5 seconds. I could not believe it. But there also some i could accelerate this process importing some data.table aggregation functions. Now emis_grid can aggegate big spatial extensions. I havent tried yet at continental scale, but I will try. Anyways, let’s go see the arguments: args(vein::emis_grid) ## function (spobj, g, sr, type = &quot;lines&quot;) ## NULL Where, spobj : A spatial dataframe of class “sp” or “sf”. When class is “sp” it is transformed to “sf”. g: A grid with class “SpatialPolygonsDataFrame” or “sf”. sr: Spatial reference e.g: 31983. It is required if spobj and g are not projected. Please, see http://spatialreference.org/. type: type of geometry: “lines” or “points”. data(net) net@data &lt;- data.frame(hdv = net[[&quot;hdv&quot;]]) g &lt;- make_grid(spobj = net, width = 1/102.47/2) ## Number of lon points: 23 ## Number of lat points: 19 netg &lt;- emis_grid(net, g) ## Sum of street emissions 148118 ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Sum of gridded emissions 148118 head(netg) ## Simple feature collection with 6 features and 2 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -46.8066 ymin: -23.62 xmax: -46.77732 ymax: -23.61512 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## id hdv geometry ## 1 1 201.8275 POLYGON ((-46.8066 -23.62, ... ## 2 2 200.6097 POLYGON ((-46.80172 -23.62,... ## 3 3 205.6319 POLYGON ((-46.79684 -23.62,... ## 4 4 224.1988 POLYGON ((-46.79196 -23.62,... ## 5 5 770.9490 POLYGON ((-46.78708 -23.62,... ## 6 6 0.0000 POLYGON ((-46.7822 -23.62, ... plot(netg[&quot;hdv&quot;], axes = TRUE) Figure 7.8: Spatial grid of HDV traffic 500 mts The example in this case, showed the allocation of traffic. The resulting object is a sf with the sum of the attributes inside each grid cell. This means that, when the input are street emissions at different hours, it will return gridded emissions at each hour: E_NOx_STREETS &lt;- emis_post(E_NOx, by = &quot;streets_wide&quot;, net = net) NOxg &lt;- emis_grid(E_NOx_STREETS, g) ## Sum of street emissions 34029872.64 ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Sum of gridded emissions 34029872.64 plot(NOxg[&quot;V1&quot;], axes = TRUE) Figure 7.9: NOx emissions for 00:00 [g/h] 7.6 Gridding top-down emissions with emis_dist When a top-down approach emissions inventory is made, the spatial distribution of emissions must be made considering some proxy. In the case of vehicular emissions, it can be done with data of Open Street Maps,distributing the emissions into the streets. This can be done with the function with the function emis_dist. In generaly, this function distribute the emissions into spatial feature on any type, not only lines. args(vein::emis_dist) ## function (gy, spobj, pro, osm, verbose = TRUE) ## NULL Where, gy: Numeric; a unique total (top-down) emissions (grams) spobj: A spatial dataframe of class “sp” or “sf”. When class is “sp” it is transformed to “sf”. pro: Matrix or data-frame profiles, for instance, pc_profile. osm: Numeric; vector of length 5, for instance, c(5, 3, 2, 1, 1). The first element covers ‘motorway’ and ‘motorway_link. The second element covers ’trunk’ and ‘trunk_link’. The third element covers ‘primary’ and ‘primary_link’. The fourth element covers ‘secondary’ and ‘secondary_link’. The fifth element covers ‘tertiary’ and ‘tertiary_link’. verbose: Logical; to show more info. In order test this function, it will be used the function osmdata. The process presented in the following code, consists in downloading the openstreetmap data delimited by the coordenaes og the grid g. Then filter only the lines library(osmdata) ## Data (c) OpenStreetMap contributors, ODbL 1.0. http://www.openstreetmap.org/copyright library(sf, quietly = T) osm &lt;- osmdata_sf( add_osm_feature( opq(bbox = st_bbox(g)), key = &#39;highway&#39;))$osm_lines[, c(&quot;highway&quot;)] st &lt;- c(&quot;motorway&quot;, &quot;motorway_link&quot;, &quot; trunk&quot;, &quot;trunk_link&quot;, &quot;primary&quot;, &quot;primary_link&quot;, &quot;secondary&quot;, &quot;secondary_link&quot;, &quot;tertiary&quot;, &quot;tertiary_link&quot;) osm &lt;- osm[osm$highway %in% st, ] plot(osm, axes = T) Figure 7.10: Open street map lines The we will distribute the total emissions of E_NOx 3.402987310^{7} into this new lines. There is the argument osm, which gives percentage weights to the type of streets in the following order: “motorway”, “trunk”, “primary”, “secondary” and “tertiary” . For instance osm = 5:1 means 33% of emissions into “motorway” because it is 5 / (1 + 2 + 3 + 4 + 5). estreet &lt;- emis_dist(gy = sum(E_NOx), spobj = osm) ## Columns: geometry emission estreet$emission_osm &lt;- emis_dist(gy = sum(E_NOx), spobj = osm, osm = 5:1)$emission ## Selecting: motorway motorway_link trunk trunk_link primary primary_link secondary secondary_link tertiary tertiary_link ## Columns: emission highway geometry plot(estreet[c(&quot;emission&quot;)], main = paste0(&quot;Emissions with Default distribution: &quot;, round(sum(estreet$emission)), &quot; [g]&quot;), axes = T,pal = cpt(colorRampPalette = T)) Figure 7.11: Emissions distributed into OSM lines plot(estreet[c(&quot;emission_osm&quot;)], main = paste0(&quot;Emission with OSM distribution: &quot;, round(sum(estreet$emission_osm)), &quot; [g]&quot;), axes = T,pal = cpt(colorRampPalette = T)) Figure 7.11: Emissions distributed into OSM lines 7.7 Gridding top-down emissions with grid_emis Another option to distribute top-down emissions consits in the use of the function grid_emis, which does a similar job than emis_dist but cell by cell. This means that the total emissions are distributed inside each grid cell and not one distribution for the whole domain. This functions runs a lapply of emis_dist, hence it takes a litle bit of more time. args(vein::grid_emis) ## function (spobj, g, sr, pro, osm, verbose = TRUE) ## NULL Where, spobj: A spatial dataframe of class “sp” or “sf”. When class is “sp” it is transformed to “sf”. g: A grid with class “SpatialPolygonsDataFrame” or “sf”. This grid includes the total emissions with the column “emission”. If profile is going to be used, the column ‘emission’ must include the sum of the emissions for each profile. For instance, if profile covers the hourly emissions, the column ‘emission’ bust be the sum of the hourly emissions. sr: Spatial reference e.g: 31983. It is required if spobj and g are not projected. Please, see http://spatialreference.org/. pro: Numeric, Matrix or data-frame profiles, for instance, pc_profile. osm: Numeric; vector of length 5, for instance, c(5, 3, 2, 1, 1). The first element covers ‘motorway’ and ‘motorway_link. The second element covers ’trunk’ and ‘trunk_link’. The third element covers ‘primary’ and ‘primary_link’. The fourth element covers ‘secondary’ and ‘secondary_link’. The fifth element covers ‘tertiary’ and ‘tertiary_link’. verbose: Logical; to show more info. It is required that the grid NOxg &lt;- NOxg[, &quot;V1&quot;] names(NOxg)[1] &lt;- &quot;emission&quot; xnet &lt;- grid_emis(osm, NOxg) ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Sum of gridded emissions 77253.6 ## Sum of street emissions 77253.6 ## Columns: emission geometry plot(xnet, axes = T,pal = cpt(colorRampPalette = T)) Figure 7.12: Use of grid_emis Appendix B "],
["he.html", "Chapter 8 Speciation 8.1 Speed functions of VOC species 8.2 Speciate function 8.3 Black carbon and organic matter 8.4 Tyre wear, breaks wear and road abrassion 8.5 \\(NO\\) and \\(NO_2\\) 8.6 Volatile organic compounds: nmhc 8.7 The speciation iag 8.8 The speciation pmiag", " Chapter 8 Speciation The speciation for emissions is a very important part that deserves a only chapter on this book. VEIN initially covered speed functions emission factors of CO, HC, NOx, PM and Fuel Consumption (FC). But currently, the the pollutants covered are: Criteria: “CO”, “NOx”, “HC”, “PM”, “CH4”, “NMHC”, “CO2”, “SO2”, “Pb”, “FC” (Fuel Consumption). Polycyclic Aromatic Hydrocarbons (PAH) and Persisten Organic Pollutants (POP): “indeno(1,2,3-cd)pyrene”, “benzo(k)fluoranthene”, “benzo(b)fluoranthene”, “benzo(ghi)perylene”, “fluoranthene”, “benzo(a)pyrene”, “pyrene”, “perylene”, “anthanthrene”, “benzo(b)fluorene”, “benzo(e)pyrene”, “triphenylene”, “benzo(j)fluoranthene”, “dibenzo(a,j)anthacene”, “dibenzo(a,l)pyrene”, “3,6-dimethyl-phenanthrene”, “benzo(a)anthracene”, “acenaphthylene”, “acenapthene”, “fluorene”, “chrysene”, “phenanthrene”, “napthalene”, “anthracene”, “coronene”, “dibenzo(ah)anthracene” Dioxins and Furans: “PCDD”, “PCDF”, “PCB”. Metals: “As”, “Cd”, “Cr”, “Cu”, “Hg”, “Ni”, “Pb”, “Se”, “Zn”. NMHC: ALKANES: “ethane”, “propane”, “butane”, “isobutane”, “pentane”, “isopentane”, “hexane”, “heptane”, “octane”, “TWO_methylhexane”, “nonane”, “TWO_methylheptane”, “THREE_methylhexane”, “decane”, “THREE_methylheptane”, “alcanes_C10_C12”, “alkanes_C13”. CYCLOALKANES: “cycloalcanes”. ALKENES: “ethylene”, “propylene”, “propadiene”, “ONE_butene”, “isobutene”, “TWO_butene”, “ONE_3_butadiene”, “ONE_pentene”, “TWO_pentene”, “ONE_hexene”, “dimethylhexene”. ALKYNES:“ONE_butine”, “propine”, “acetylene”. ALDEHYDES: “formaldehyde”, “acetaldehyde”, “acrolein”, “benzaldehyde”, “crotonaldehyde”, “methacrolein”, “butyraldehyde”, “isobutanaldehyde”, “propionaldehyde”, “hexanal”, “i_valeraldehyde”, “valeraldehyde”, “o_tolualdehyde”, “m_tolualdehyde”, “p_tolualdehyde”. KETONES: “acetone”, “methylethlketone”. AROMATICS: “toluene”, “ethylbenzene”, “m_p_xylene”, “o_xylene”, “ONE_2_3_trimethylbenzene”, “ONE_2_4_trimethylbenzene”, “ONE_3_5_trimethylbenzene”, “styrene”, “benzene”, “C9”, “C10”, “C13”. Also, some Brazilian emission factors and speciations for WRF-Chem, mechanisms: “e_eth”, “e_hc3”, “e_hc5”, “e_hc8”, “e_ol2”, “e_olt”, “e_oli”, “e_iso”, “e_tol”, “e_xyl”, “e_c2h5oh”, “e_ald”, “e_hcho”, “e_ch3oh”, “e_ket”, “E_SO4i”, “E_SO4j”, “E_NO3i”, “E_NO3j”, “E_MP2.5i”, “E_MP2.5j”, “E_ORGi”, “E_ORGj”, “E_ECi”, “E_ECj”, “H2O”. By the end of this book, more emission factors will be added. Because VEIN has the capabilities to produce species from this pollutants including volatile organic compunds (VOC) and particulate matter compounds. The speciation of emissions in VEIN can be done with three ways, by selecting the pollutants in ef_speed* functions, other way explicit and the other implicit. The explicit way is by usint the function speciate for the specific available speciation. The implicit way is by adding a percentage value in the argument k in any of the functions of emission factors. The implicit way requires that the user must know the percentage of the species of pollutant. 8.1 Speed functions of VOC species As mentioned before, the speed function emission factors, currently covers several pollutants. We firstly focus on som PAH and POP. They way to select them is just: library(vein) pol &lt;- c(&quot;indeno(1,2,3-cd)pyrene&quot;, &quot;benzo(k)fluoranthene&quot;, &quot;benzo(b)fluoranthene&quot;, &quot;benzo(ghi)perylene&quot;, &quot;fluoranthene&quot;, &quot;benzo(a)pyrene&quot;) df &lt;- lapply(1:length(pol), function(i){ EmissionFactors(ef_ldv_speed(&quot;PC&quot;, &quot;4S&quot;, &quot;&lt;=1400&quot;, &quot;G&quot;, &quot;PRE&quot;, pol[i], x = 10)(10)) }) names(df) &lt;- pol df ## $`indeno(1,2,3-cd)pyrene` ## 1.03e-06 [g/km] ## ## $`benzo(k)fluoranthene` ## 3e-07 [g/km] ## ## $`benzo(b)fluoranthene` ## 8.8e-07 [g/km] ## ## $`benzo(ghi)perylene` ## 2.9e-06 [g/km] ## ## $fluoranthene ## 1.822e-05 [g/km] ## ## $`benzo(a)pyrene` ## 4.8e-07 [g/km] These pollutants comes from Ntziachristos and Samaras (2016) and in this case, are not dependent on speed. I used lapply to iterate in each pollutant at 10 km/h. Now I will show the same for dioxins and furans. library(vein) pol &lt;- c(&quot;PCDD&quot;, &quot;PCDF&quot;, &quot;PCB&quot;) df &lt;- lapply(1:length(pol), function(i){ EmissionFactors(ef_ldv_speed(&quot;PC&quot;, &quot;4S&quot;, &quot;&lt;=1400&quot;, &quot;G&quot;, &quot;PRE&quot;, pol[i], x = 10)(10)) }) names(df) &lt;- pol df ## $PCDD ## 1.03e-11 [g/km] ## ## $PCDF ## 2.12e-11 [g/km] ## ## $PCB ## 6.4e-12 [g/km] In the case of nmhc, the estimation is: library(vein) pol &lt;- c(&quot;ethane&quot;, &quot;propane&quot;, &quot;butane&quot;, &quot;isobutane&quot;, &quot;pentane&quot;) df &lt;- lapply(1:length(pol), function(i){ EmissionFactors(ef_ldv_speed(&quot;PC&quot;, &quot;4S&quot;, &quot;&lt;=1400&quot;, &quot;G&quot;, &quot;PRE&quot;, pol[i], x = 10)(c(10,20,30))) }) names(df) &lt;- pol df ## $ethane ## Units: [g/km] ## [1] 0.09934632 0.06062781 0.04524681 ## ## $propane ## Units: [g/km] ## [1] 0.02829865 0.01726974 0.01288849 ## ## $butane ## Units: [g/km] ## [1] 0.1746087 0.1065580 0.0795247 ## ## $isobutane ## Units: [g/km] ## [1] 0.07767076 0.04739993 0.03537478 ## ## $pentane ## Units: [g/km] ## [1] 0.10717361 0.06540455 0.04881171 Now the same example for one pollutant and several euro standards. library(vein) euro &lt;- c(&quot;V&quot;, &quot;IV&quot;, &quot;III&quot;, &quot;II&quot;,&quot;I&quot;, &quot;PRE&quot;) df &lt;- lapply(1:length(euro), function(i){ EmissionFactors(ef_ldv_speed(&quot;PC&quot;, &quot;4S&quot;, &quot;&lt;=1400&quot;, &quot;G&quot;, euro[i], &quot;benzene&quot;)(c(10, 30, 50))) }) names(df) &lt;- euro df ## $V ## Units: [g/km] ## [1] 0.0003928819 0.0002194495 0.0001597751 ## ## $IV ## Units: [g/km] ## [1] 0.0004864655 0.0004872061 0.0005276205 ## ## $III ## Units: [g/km] ## [1] 0.0017465678 0.0008206890 0.0005928019 ## ## $II ## Units: [g/km] ## [1] 0.013332523 0.004133087 0.002363304 ## ## $I ## Units: [g/km] ## [1] 0.025656752 0.010921829 0.006979341 ## ## $PRE ## Units: [g/km] ## [1] 0.4112336 0.1872944 0.1287895 8.2 Speciate function The arguments of the function speciate are: args(vein::speciate) ## function (x, spec = &quot;bcom&quot;, veh, fuel, eu, show = FALSE, list = FALSE, ## dx) ## NULL Where, x: Emissions estimation spec: speciation: The speciations are: “bcom”, tyre“,”break“,”road“,”iag“,”nox&quot; and “nmhc”. ‘iag’ now includes a speciation for use of industrial and building paintings. “bcom” stands for black carbon and organic matter. veh: Type of vehicle: When spec is “bcom” or “nox” veh can be “PC”, “LCV”, HDV&quot; or “Motorcycle”. When spec is “iag” veh can take two values depending: when the speciation is for vehicles veh accepts “veh”, eu “Evaporative”, “Liquid” or “Exhaust” and fuel “G”, “E” or “D”, when the speciation is for painting, veh is “paint” fuel or eu can be “industrial” or “building” when spec is “nmhc”, veh can be “LDV” with fuel “G” or “D” and eu “PRE”, “I”, “II”, “III”, “IV”, “V”, or “VI”. when spec is “nmhc”, veh can be “HDV” with fuel “D” and eu “PRE”, “I”, “II”, “III”, “IV”, “V”, or “VI”. when spec is “nmhc” and fuel is “LPG”, veh and eu must be “ALL” fuel: Fuel. When spec is “bcom” fuel can be “G” or “D”. When spec is “iag” fuel can be “G”, “E” or “D”. When spec is “nox” fuel can be “G”, “D”, “LPG”, “E85” or “CNG”. Not required for “tyre”, “break” or “road”. When spec is “nmhc” fuel can be G, D or LPG. eu: sEuro emission standard: “PRE”, “ECE_1501”, “ECE_1502”, “ECE_1503”, “I”, “II”, “III”, “IV”, “V”, “III-CDFP”,“IV-CDFP”,“V-CDFP”, “III-ADFP”, “IV-ADFP”,“V-ADFP” and “OPEN_LOOP”. When spec is “iag” accept the values “Exhaust” “Evaporative” and “Liquid”. When spec is “nox” eu can be “PRE”, “I”, “II”, “III”, “IV”, “V”, “VI”, “VIc”, “III-DPF” or “III+CRT”. Not required for “tyre”, “break” or “road” show: when TRUE shows row of table with respective speciation list: when TRUE returns a list with number of elements of the list as the number species of pollutants As shown before, there are currently 8 type of speciations. Now, i will show examples for most of them. 8.3 Black carbon and organic matter Let’s use the data inside the vein and estimate emissions. The vehicles considered are Light Trucks, assuming all HGV. We are using the 4 stage estimation with the first part arranging traffic data library(vein) # 1 Traffic data data(net) data(profiles) data(fe2015) lt &lt;- age_hdv(net$ldv) ## Average age of age is 17.12 ## Number of age is 1946.95 * 10^3 veh vw &lt;- temp_fact(net$ldv, profiles$PC_JUNE_2014) + temp_fact(net$hdv, profiles$HGV_JUNE_2014) speed &lt;- netspeed(vw, net$ps, net$ffs, net$capacity, net$lkm, alpha = 1) # 2 Emission factors euro &lt;- c(&quot;V&quot;, rep(&quot;IV&quot;, 3), rep(&quot;III&quot;, 7), rep(&quot;II&quot;, 7), rep(&quot;I&quot;, 5), rep(&quot;PRE&quot;, 27)) lefd &lt;- lapply(1:50, function(i) { ef_hdv_speed(v = &quot;Trucks&quot;, t = &quot;RT&quot;, g = &quot;&gt;32&quot;, gr = 0, eu = euro[i], l = 0.5, p = &quot;PM&quot;, show.equation = FALSE) }) # 3 Estimate emissions pmd &lt;- emis(veh = lt, lkm = net$lkm, ef = lefd, speed = speed, profile = profiles$HGV_JUNE_2014) ## 32714.53 kg emissions in 24 hours and 7 days # 4 process emissions # Agreggating emissions by age of use df &lt;- apply(X = pmd, MARGIN = c(1,2), FUN = sum, na.rm = TRUE) euro ## [1] &quot;V&quot; &quot;IV&quot; &quot;IV&quot; &quot;IV&quot; &quot;III&quot; &quot;III&quot; &quot;III&quot; &quot;III&quot; &quot;III&quot; &quot;III&quot; &quot;III&quot; ## [12] &quot;II&quot; &quot;II&quot; &quot;II&quot; &quot;II&quot; &quot;II&quot; &quot;II&quot; &quot;II&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; &quot;I&quot; ## [23] &quot;I&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; ## [34] &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; ## [45] &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; &quot;PRE&quot; dfbcom &lt;- rbind(speciate(df[, 1], &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, &quot;V&quot;), speciate(rowSums(df[, 2:4]), &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, &quot;IV&quot;), speciate(rowSums(df[, 5:11]), &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, &quot;III&quot;), speciate(rowSums(df[, 12:18]), &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, &quot;II&quot;), speciate(rowSums(df[, 19:23]), &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, &quot;I&quot;), speciate(rowSums(df[, 24:50]), &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, &quot;PRE&quot;)) dfbcom$id &lt;- 1:1505 bc &lt;- aggregate(dfbcom$BC, by = list(dfbcom$id), sum) om &lt;- aggregate(dfbcom$OM, by = list(dfbcom$id), sum) net$BC &lt;- bc[, 2] net$OM &lt;- om[, 2] Now we have spatial objects of Back Carbon sp::spplot(net, &quot;BC&quot;, scales = list(draw = T), main = &quot;Black Carbon [g/168h]&quot;, col.regions = rev(cptcity::cpt())) Figure 8.1: Black Carbon [g/168h] and Organic Matter sp::spplot(net, &quot;OM&quot;, scales = list(draw = T), main = &quot;Organic Matter [g/168h]&quot;, col.regions = rev(cptcity::cpt())) Figure 8.2: Organic Matter [g/168h] If you are interested in speciate total emissions by age of use not spatial emissions, you could use emis_post with by = &quot;veh&quot; and then aggregate the emissions by standard. Then speciate PM by standard: dfpm &lt;- emis_post(arra = pmd, veh = &quot;LT&quot;, size = &quot;small&quot;, fuel = &quot;D&quot;, pollutant = &quot;PM&quot;, by = &quot;veh&quot;) dfpm$euro &lt;- euro dfpmeuro &lt;- aggregate(dfpm$g, by = list(dfpm$euro), sum) names(dfpmeuro) &lt;- c(&quot;euro&quot;, &quot;g&quot;) bcom &lt;- as.data.frame(sapply(1:6, function(i){ speciate(dfpmeuro$g[i], &quot;bcom&quot;, &quot;PC&quot;, &quot;D&quot;, dfpmeuro$euro[i]) })) names(bcom) &lt;- dfpmeuro$euro And the resulting speciation is: Table 8.1: Black Carbon and Organic Matter [g/168h] I II III IV PRE V BC 6826527.37503195 5313757.92745243 3321183.01325297 155078.69338865 6700527.80930883 10369.2555188646 OM 2730610.95001278 1222164.32331406 498177.451987945 20160.2301405245 4690369.46651618 20738.5110377293 8.4 Tyre wear, breaks wear and road abrassion Tyre, break and road abrassions comes from Ntziachristos and Boulter (2009). Tyres consist in a complex mixture of rubber, which after the use starts to degradate. In deed, when the driving cycle ismore aggresive, higher is tyre mass emitted from tyre, with tyre wear emission factors higher in HDV than LDV. Break wear emits mass and with more aggresive driving, more emissions. The input are wear emissions in Total Suspended Particles (TSP) ,as explained in section @ref(#ew). The speciation consists in 60% PM10, 42% PM2.5, 6% PM1 and 4.8% PM0.1. Now, a simple example for TP adspeciation: library(vein) data(net) data(profiles) pro &lt;- profiles$PC_JUNE_2012[, 1] # 24 hours pc_week &lt;- temp_fact(net$ldv+net$hdv, pro) df &lt;- netspeed(pc_week, net$ps, net$ffs, net$capacity, net$lkm, alpha = 1) ef &lt;- ef_wear(wear = &quot;tyre&quot;, type = &quot;PC&quot;, speed = df) emit &lt;- emis_wear(veh = age_ldv(net$ldv, name = &quot;VEH&quot;), speed = df, lkm = net$lkm, ef = ef, profile = pro) ## Average age of VEH is 11.17 ## Number of VEH is 1946.95 * 10^3 veh emib &lt;- emis_wear(what = &quot;break&quot;, veh = age_ldv(net$ldv, name = &quot;VEH&quot;), lkm = net$lkm, ef = ef, profile = pro, speed = df) ## Average age of VEH is 11.17 ## Number of VEH is 1946.95 * 10^3 veh emit ## This EmissionsArray has ## 1505 streets ## 50 vehicle categories ## 24 hours ## 1 days ## [1] 0.0499920404 0.0183982869 0.0026973699 0.0066891571 0.0002749512 ## [6] 0.0212774028 emib ## This EmissionsArray has ## 1505 streets ## 50 vehicle categories ## 24 hours ## 1 days ## [1] 0.0528581237 0.0153135442 0.0022451163 0.0070774117 0.0002288516 ## [6] 0.0271699850 emitp &lt;- emis_post(arra = emit, veh = &quot;PC&quot;, size = &quot;ALL&quot;, fuel = &quot;G&quot;, pollutant = &quot;TSP&quot;, by = &quot;veh&quot;) emibp &lt;- emis_post(arra = emib, veh = &quot;PC&quot;, size = &quot;ALL&quot;, fuel = &quot;G&quot;, pollutant = &quot;TSP&quot;, by = &quot;veh&quot;) The estimation covered 24 hours and for simplicity, we are assuming a year with 365 similar days and dividing by 1 million to have t/y. Hence,the speciation is: library(ggplot2) tyrew &lt;- speciate(x = unclass(emitp$g), spec = &quot;tyre&quot;) breakw &lt;- speciate(x = unclass(emibp$g), spec = &quot;brake&quot;) df &lt;- data.frame(Emis = c(sapply(tyrew, sum), sapply(breakw, sum))*365/1000000) df$Pollutant &lt;- factor(x = names(tyrew), levels = names(tyrew)) df$Emissions &lt;- c(rep(&quot;Tyre&quot;, 4), rep(&quot;Brake&quot;, 4)) ggplot(df, aes(x = Pollutant, y = Emis, fill = Emissions)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;)+ labs(x = NULL, y = &quot;[t/y]&quot;) Figure 8.3: Break and Tyre emissions (t/y) It is interesting to see that break emissions are higher than tyre wear emissions, and the smalle the diameter, higher the difference, as shows: Table 8.2: Ratio between break and tyre wear emissions x PM10 1.6593167 PM2.5 0.9433433 PM1 1.6931803 PM0.1 1.6931803 The procudure can be used with emis_post with by = streets_wide to obtain the spatial speciation. 8.5 \\(NO\\) and \\(NO_2\\) The speciation of \\(NO_X\\) into \\(NO\\) and \\(NO2\\) depends on the type of vehicle, fuel and euro standard. The following example will consists in comparing a Gasoline passenger car and a Diesel truck. library(vein) data(net) data(profiles) propc &lt;- profiles$PC_JUNE_2012[, 1] # 24 hours prolt &lt;- profiles$PC_JUNE_2012[, 1] # 24 hours pweek &lt;- temp_fact(net$ldv+net$hdv, pro) df &lt;- netspeed(pc_week, net$ps, net$ffs, net$capacity, net$lkm, alpha = 1) euro &lt;- c(&quot;V&quot;, rep(&quot;IV&quot;, 3), rep(&quot;III&quot;, 7), rep(&quot;II&quot;, 7), rep(&quot;I&quot;, 5), rep(&quot;PRE&quot;, 27)) lefpc &lt;- lapply(1:50, function(i) { ef_ldv_speed(v = &quot;PC&quot;, t = &quot;4S&quot;, cc = &quot;&lt;=1400&quot;, f = &quot;G&quot;, eu = euro[i], p = &quot;NOx&quot;, show.equation = FALSE) }) leflt &lt;- lapply(1:50, function(i) { ef_hdv_speed(v = &quot;Trucks&quot;, t = &quot;RT&quot;, g = &quot;&gt;32&quot;, gr = 0, eu = euro[i], l = 0.5, p = &quot;NOx&quot;, show.equation = FALSE) }) emipc &lt;- emis(veh = age_ldv(net$ldv),lkm = net$lkm, ef = lefpc, speed = df, profile = profiles$PC_JUNE_2014[, 1])*365/1000000 ## Average age of age is 11.17 ## Number of age is 1946.95 * 10^3 veh ## 4097.62 kg emissions in 24 hours and 1 days emilt &lt;- emis(veh = age_ldv(net$hdv),lkm = net$lkm, ef = leflt, speed = df, profile = profiles$HGV_JUNE_2014[, 1])*365/1000000 ## Average age of age is 11.17 ## Number of age is 148.12 * 10^3 veh ## 14612.67 kg emissions in 24 hours and 1 days Then, once the emissions are estimated, we will speciate the emissions by euro standard. The estimation covered 24 hours and for simplicity, we are assuming a year with 365 similar days and dividing by 1 million to have t/y. df &lt;- rowSums(apply(X = emipc, MARGIN = c(2,3), FUN = sum, na.rm = TRUE)) dfpc &lt;- rbind(speciate(df[1], &quot;nox&quot;, &quot;PC&quot;, &quot;G&quot;, &quot;V&quot;), speciate(df[2:4], &quot;nox&quot;, &quot;PC&quot;, &quot;G&quot;, &quot;V&quot;), speciate(df[5:11], &quot;nox&quot;, &quot;PC&quot;, &quot;G&quot;, &quot;V&quot;), speciate(df[12:18], &quot;nox&quot;, &quot;PC&quot;, &quot;G&quot;, &quot;V&quot;), speciate(df[19:23], &quot;nox&quot;, &quot;PC&quot;, &quot;G&quot;, &quot;V&quot;), speciate(df[24:50], &quot;nox&quot;, &quot;PC&quot;, &quot;G&quot;, &quot;V&quot;)) df &lt;- rowSums(apply(X = emipc, MARGIN = c(2,3), FUN = sum, na.rm = TRUE)) dfhdv &lt;- rbind(speciate(df[1], &quot;nox&quot;, &quot;HDV&quot;, &quot;D&quot;, &quot;V&quot;), speciate(df[2:4], &quot;nox&quot;, &quot;HDV&quot;, &quot;D&quot;, &quot;V&quot;), speciate(df[5:11], &quot;nox&quot;, &quot;HDV&quot;, &quot;D&quot;, &quot;V&quot;), speciate(df[12:18], &quot;nox&quot;, &quot;HDV&quot;, &quot;D&quot;, &quot;V&quot;), speciate(df[19:23], &quot;nox&quot;, &quot;HDV&quot;, &quot;D&quot;, &quot;V&quot;), speciate(df[24:50], &quot;nox&quot;, &quot;HDV&quot;, &quot;D&quot;, &quot;V&quot;)) df &lt;- data.frame(rbind(sapply(dfpc, sum), sapply(dfhdv, sum))) row.names(df) &lt;- c(&quot;PC&quot;, &quot;HGV&quot;) knitr::kable(df, caption = &quot;NO2 and NO speciation (t/y)&quot;) Table 8.3: NO2 and NO speciation (t/y) NO2 NO PC 44.8689 1450.761 HGV 179.4756 1316.154 8.6 Volatile organic compounds: nmhc nmhc were shown earluier in this chapter, but they can be also used to speciate objects, resulting in all species at once. The speciation of NMHC must be applied to NMHC. However, the emission guidelines of Ntziachristos and Samaras (2016) does not show explicit emission factor of NMHC and the suggeted procedure is substract the \\(CH_4\\) from the \\(HC\\). This was done on VEIN and now, ef_speed* functions returns NMHC directly. This makes easier to produce speciation. library(vein) data(net) data(profiles) propc &lt;- profiles$PC_JUNE_2012[, 1] # 24 hours pweek &lt;- temp_fact(net$ldv+net$hdv, propc) df &lt;- netspeed(pweek, net$ps, net$ffs, net$capacity, net$lkm, alpha = 1) euro &lt;- c(&quot;V&quot;, rep(&quot;IV&quot;, 3), rep(&quot;III&quot;, 7), rep(&quot;II&quot;, 7), rep(&quot;I&quot;, 5), rep(&quot;PRE&quot;, 27)) lefpc &lt;- lapply(1:50, function(i) { ef_ldv_speed(v = &quot;PC&quot;, t = &quot;4S&quot;, cc = &quot;&lt;=1400&quot;, f = &quot;G&quot;, eu = euro[i], p = &quot;NMHC&quot;, show.equation = FALSE)}) euro &lt;- c(&quot;V&quot;, rep(&quot;IV&quot;, 3), rep(&quot;III&quot;, 7), rep(&quot;II&quot;, 7), rep(&quot;I&quot;, 5), rep(&quot;PRE&quot;, 27)) lefpc &lt;- lapply(1:length(euro), function(i) { ef_ldv_speed(v = &quot;PC&quot;, t = &quot;4S&quot;, cc = &quot;&lt;=1400&quot;, f = &quot;G&quot;, eu = euro[i], p = &quot;HC&quot;, show.equation = FALSE) }) enmhc &lt;- emis(veh = age_ldv(net$ldv), lkm = net$lkm, ef = lefpc, speed = df, profile = profiles$PC_JUNE_2014[, 1]) ## Average age of age is 11.17 ## Number of age is 1946.95 * 10^3 veh ## 3030.65 kg emissions in 24 hours and 1 days df_enmhc &lt;- emis_post(arra = enmhc, veh = &quot;PC&quot;, size = &quot;ALL&quot;, fuel = &quot;G&quot;, pollutant = &quot;NMHC&quot;, by = &quot;veh&quot;) # assuming all euro I spec &lt;- speciate(x = as.numeric(df_enmhc$g), spec = &quot;nmhc&quot;, veh = &quot;LDV&quot;, fuel = &quot;G&quot;, eu = &quot;I&quot;) names(spec) ## [1] &quot;ethane&quot; &quot;propane&quot; ## [3] &quot;butane&quot; &quot;isobutane&quot; ## [5] &quot;pentane&quot; &quot;isopentane&quot; ## [7] &quot;hexane&quot; &quot;heptane&quot; ## [9] &quot;octane&quot; &quot;TWO_methylhexane&quot; ## [11] &quot;nonane&quot; &quot;TWO_methylheptane&quot; ## [13] &quot;THREE_methylhexane&quot; &quot;decane&quot; ## [15] &quot;THREE_methylheptane&quot; &quot;alcanes_C10_C12&quot; ## [17] &quot;alkanes_C13&quot; &quot;cycloalcanes&quot; ## [19] &quot;ethylene&quot; &quot;propylene&quot; ## [21] &quot;propadiene&quot; &quot;ONE_butene&quot; ## [23] &quot;isobutene&quot; &quot;TWO_butene&quot; ## [25] &quot;ONE_3_butadiene&quot; &quot;ONE_pentene&quot; ## [27] &quot;TWO_pentene&quot; &quot;ONE_hexene&quot; ## [29] &quot;dimethylhexene&quot; &quot;ONE_butine&quot; ## [31] &quot;propine&quot; &quot;acetylene&quot; ## [33] &quot;formaldehyde&quot; &quot;acetaldehyde&quot; ## [35] &quot;acrolein&quot; &quot;benzaldehyde&quot; ## [37] &quot;crotonaldehyde&quot; &quot;methacrolein&quot; ## [39] &quot;butyraldehyde&quot; &quot;isobutanaldehyde&quot; ## [41] &quot;propionaldehyde&quot; &quot;hexanal&quot; ## [43] &quot;i_valeraldehyde&quot; &quot;valeraldehyde&quot; ## [45] &quot;o_tolualdehyde&quot; &quot;m_tolualdehyde&quot; ## [47] &quot;p_tolualdehyde&quot; &quot;acetone&quot; ## [49] &quot;methylethlketone&quot; &quot;toluene&quot; ## [51] &quot;ethylbenzene&quot; &quot;m_p_xylene&quot; ## [53] &quot;o_xylene&quot; &quot;ONE_2_3_trimethylbenzene&quot; ## [55] &quot;ONE_2_4_trimethylbenzene&quot; &quot;ONE_3_5_trimethylbenzene&quot; ## [57] &quot;styrene&quot; &quot;benzene&quot; ## [59] &quot;C9&quot; &quot;C10&quot; ## [61] &quot;C13&quot; 8.7 The speciation iag The Carbon Bond Mechanism Z (1999) is an lumped-structure mechanism. Citing: **“it is currently unfeasible to treat the organic species individually in a regional or global chemistry model for three major reasons:** - (1) limited computational resources, - (2) lack of detailed speciated emissions inventories, and - (3) lack of kinetic and mechanistic information for all the species and their reaction products. Thus there exists a need for a condensed mechanism that is capable of describing the tropospheric hydrocarbon chemistry with reasonable accuracy, sensitivity, and speed at regional to global scales. The research in this aspect is intense and out of the scope of this book. However, it is important that the user who intends to performs atmospheric simulation to understand this why it is important to speciate the emissions and what represent each group. A popular air quality model nowedays is the Weather Research and Forecasting model coupled to Chemistry (WRF-Chem) (Grell et al. 2005) https://ruc.noaa.gov/wrf/wrf-chem/and the Emissions Guide (https://ruc.noaa.gov/wrf/wrf-chem/Emission_guide.pdf). The speciation iag splits the NMHC into the lumped groups for the mechanism CMB-Z. The name iag comes from the Institute of Astronomy, Geophysics and Atmospheric Sciences (IAG, http://www.iag.usp.br/) from the University of São Paulo (USP). The Departament of Atmospheric Sciences (DAC) of IAG has measure and model air quality models for several years. There are several scientific production such as: Nogueira et al. (2015), Hoshyaripour et al. (2016), Andrade et al. (2017), Freitas et al. (2005), Martins et al. (2006), Pérez-Martinez et al. (2014), Ulke and Andrade (2001), Vivanco and Fátima Andrade (2006), Boian and Andrade (2012), Fatima Andrade et al. (2012), Andrade et al. (2015), Vara-Vela et al. (2016), Rafee (2015), S. Ibarra-Espinosa et al. (2017). The following figure, shows an air quality simulation over South Easth Brazil from DAC/IAG/USP. Figure 8.4: http://www.lapat.iag.usp.br/aerossol/wrf9/index.php Some of these papers show measurements in tunnels, fuel, etc. The speciation iag it is based on these experiments, and the last versions, covers an update during 2015 so that the exhaust emissions speciation is more representative of brazilian gasoline. This means that: ** THE SPECIATION IAG IS BASED ON BRAZILIAN MEASUREMENTS**. and the user who wants to applt it outside Brazil, should be ensure, that the fleet and fuel are compatible. As that will be hard to accomplish, I can say that this speciation is for and to be used in Brazil, even more, in São Paulo. The currently speciation iag is: Figure 8.5: Speciation for NMHC by type of fuel and process mol/100g (Ibarra-Espinosa, S., 2017) The arguments of the function speciate take the following form: x: Emissions estimation, it is recommended that x are griddded emissions from NMHC. spec: iag. Alternatively, you can put any name of the following: “e_eth”, “e_hc3”, “e_hc5”, “e_hc8”, “e_ol2”, “e_olt”, “e_oli”, “e_iso”, “e_tol”, “e_xyl”, “e_c2h5oh”, “e_hcho”, “e_ch3oh”, “e_ket” veh: When spec is “iag” veh can take two values depending: when the speciation is for vehicles veh accepts “veh”, eu “Evaporative”, “Liquid” or “Exhaust” fuel: “G”, “E” or “D”. eu: “Exhaust” “Evaporative” or “Liquid”. show: Let this FALSE. list: Let this TRUE so that the result is a list, and each element of the list a lumped specie. Example: # Do not run x &lt;- data.frame(x = rnorm(n = 100, mean = 400, sd = 2)) dfa &lt;- speciate(x, spec = &quot;e_eth&quot;, veh = &quot;veh&quot;, fuel = &quot;G&quot;, eu = &quot;Exhaust&quot;) head(dfa) ## e_eth ## 1 0.9303829 ## 2 0.9336580 ## 3 0.9244302 ## 4 0.9243937 ## 5 0.9384012 ## 6 0.9307047 df &lt;- speciate(x, spec = &quot;iag&quot;, veh = &quot;veh&quot;, fuel = &quot;G&quot;, eu = &quot;Exhaust&quot;, list = TRUE) names(df) ## [1] &quot;e_eth&quot; &quot;e_hc3&quot; &quot;e_hc5&quot; &quot;e_hc8&quot; &quot;e_ol2&quot; &quot;e_olt&quot; ## [7] &quot;e_oli&quot; &quot;e_iso&quot; &quot;e_tol&quot; &quot;e_xyl&quot; &quot;e_c2h5oh&quot; &quot;e_ald&quot; ## [13] &quot;e_hcho&quot; &quot;e_ch3oh&quot; &quot;e_ket&quot; for(i in 1:length(df)){ print(df[[i]][1:3, ]) # Firt three lines of each element of the list } ## Units: [mol/h] ## [1] 0.9303829 0.9336580 0.9244302 ## Units: [mol/h] ## [1] 1.432668 1.437711 1.423501 ## Units: [mol/h] ## [1] 0.5221647 0.5240028 0.5188238 ## Units: [mol/h] ## [1] 0.2519576 0.2528446 0.2503456 ## Units: [mol/h] ## [1] 1.911691 1.918420 1.899460 ## Units: [mol/h] ## [1] 0.8014558 0.8042771 0.7963281 ## Units: [mol/h] ## [1] 0.5313376 0.5332080 0.5279380 ## Units: [mol/h] ## [1] 0.02548693 0.02557665 0.02532387 ## Units: [mol/h] ## [1] 0.4625368 0.4641650 0.4595774 ## Units: [mol/h] ## [1] 0.8812075 0.8843095 0.8755694 ## Units: [mol/h] ## [1] 1.237796 1.242153 1.229876 ## Units: [mol/h] ## [1] 0.3469719 0.3481933 0.3447519 ## Units: [mol/h] ## [1] 0.4525245 0.4541175 0.4496292 ## Units: [mol/h] ## [1] 0 0 0 ## Units: [mol/h] ## [1] 0 0 0 8.8 The speciation pmiag The speciation pmiagis also based on IAG studies and applied only for PM2.5 emissions. The speciation splits the PM2.5 in percentages as follow: Table 8.4: Speciation of PM2.5 E_SO4i E_SO4j E_NO3i E_NO3j E_MP2.5i E_MP2.5j E_ORGi E_ORGj E_ECi E_ECj H2O 0.0077 0.0623 0.00247 0.01053 0.1 0.3 0.0304 0.1296 0.056 0.024 0.277 When running this speciation, the only two required arguments are x and spec. Also, There is a message that this speciation applies only in gridded emissions, because the unit must be in flux \\(g/km^2/h\\), and internally are transformed to the required unit $ g/m^2/s$ as: \\[ \\frac{g}{(km)^2*h}*\\frac{10^6 \\mu g}{g}*(\\frac{km}{1000m})^2*\\frac{h}{3600s}\\frac{1}{dx^2}\\] dx is the length of the grid cell. Example: library(vein) data(net) pm &lt;- data.frame(pm = rnorm(n = length(net), mean = 400, sd = 2)) net@data &lt;- pm g &lt;- make_grid(net, 1/102.47/2) # 500 m ## Number of lon points: 23 ## Number of lat points: 19 gx &lt;- emis_grid(net, g) ## Sum of street emissions 602016.38 ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Sum of gridded emissions 602016.38 df &lt;- speciate(gx, spec = &quot;pmiag&quot;, veh = &quot;veh&quot;, fuel = &quot;G&quot;, eu = &quot;Exhaust&quot;, list = FALSE, dx = 0.5) ## To be used in emissions grid only, emissions must be in g/(Xkm^2)/h ## PM.2.5-10 must be calculated as substraction of PM10-PM2.5 to enter this variable into WRF names(df) ## [1] &quot;e_so4i&quot; &quot;e_so4j&quot; &quot;e_no3i&quot; &quot;e_no3j&quot; &quot;e_pm2.5i&quot; &quot;e_pm2.5j&quot; ## [7] &quot;e_orgi&quot; &quot;e_orgj&quot; &quot;e_eci&quot; &quot;e_ecj&quot; &quot;h2o&quot; head(df) ## e_so4i e_so4j e_no3i e_no3j e_pm2.5i ## 1 0.001441152 [g/m^2/s] 0.01166023 0.0004622915 0.001970822 0.01871626 ## 2 0.001432456 [g/m^2/s] 0.01158987 0.0004595023 0.001958931 0.01860333 ## 3 0.001468318 [g/m^2/s] 0.01188002 0.0004710058 0.002007972 0.01906906 ## 4 0.002537392 [g/m^2/s] 0.02052981 0.0008139427 0.003469966 0.03295315 ## 5 0.005760086 [g/m^2/s] 0.04660433 0.0018477158 0.007877104 0.07480631 ## 6 0.000000000 [g/m^2/s] 0.00000000 0.0000000000 0.000000000 0.00000000 ## e_pm2.5j e_orgi e_orgj e_eci e_ecj h2o ## 1 0.05614877 0.005689742 0.02425627 0.01048110 0.004491902 0.05184403 ## 2 0.05580999 0.005655412 0.02410992 0.01041786 0.004464799 0.05153122 ## 3 0.05720718 0.005796994 0.02471350 0.01067867 0.004576575 0.05282130 ## 4 0.09885944 0.010017757 0.04270728 0.01845376 0.007908755 0.09128022 ## 5 0.22441893 0.022741118 0.09694898 0.04189153 0.017953514 0.20721348 ## 6 0.00000000 0.000000000 0.00000000 0.00000000 0.000000000 0.00000000 Appendix B "],
["ep.html", "Chapter 9 Inputs for atmospheric models 9.1 WRFChem input with wrfinput and GriddedEmissionsArray", " Chapter 9 Inputs for atmospheric models This last chapter of this book is about generating inputs for atmospheric models, specifically, WRF-Chem (Grell et al. 2005). As the Pacific Northwest National Laboratory (PNNL, https://www.pnnl.gov/atmospheric/research/wrf-chem/) defines: The Weather Research and Forecasting (WRF) model is a next generation meteorological model being developed collaboratively among several agencies (NOAA/NCEP, NOAA/ESRL, NCAR). WRF-Chem is a version of WRF that also simultaneously simulates the emission, turbulent mixing, transport, transformation, and fate of trace gases and aerosols. Initially, VEIN counted with the function emis_wrf which created a data.frame object of hourly gridded emissions with each pollutant as a column, from the first cell to the last. The data-frame extendend in long format to each hour. This data.frame was designed to be used with script Another Asimilation System for WRF (AS4WRF) (Vara-Vela et al. 2016) written in NCL (Boulder 2017). This approach was effective and already tested for some Latinamerican cities (Ibarra et al. 2015), (Ibarra, Ynoue, and Vara-Vela 2015). However, this function depends on external software which may not be available. Therefore, me andsome collegues developed the package eixport (Ibarra-Espinosa, Schuch, and Dias de Freitas 2018), (Ibarra-Espinosa, Schuch, and de Freitas 2017), which is an R package to read and export emissions to atmospheric models. eixport currently covers the models WRF-Chem (Grell et al. 2005), SPM-BRAMS (Freitas et al. 2005) and R-LINE (Snyder et al. 2013), but only the WRF-Chem interface has been fully implemented. Therefore, this chapter covers only this model. The concept of connecting VEIN and Wrf-Chem via eixport is quite simple with two approaches: Generating GriddedEmissionsArray for the wrfinput grid and inputting this emissions into the wrfchemi input file.. Generating gridded emissions data-frame for AS4WRF. 9.1 WRFChem input with wrfinput and GriddedEmissionsArray The process for generation WRF-Chem input files with GriddedEmissionsArray is shown on Fig. 9.1. Pink boxes are classes, grey boxes are vein functions, green functions are eixport functions and white boxes, external objects. Here, the external input file is the wrfinputd_0x file, where the x is for the domain. This file is inputted into the function make_grid which creates a polygon grid needed by emis_grid. The main characteristic of this grid, is that it has the resolution of the wrfinput file. The wrfinpiut_d0x file isalso used by the eixport function wrf_create to create a wrfchemi input file with zeroes. The objects with class EmissionsArray for each type of vehicle and pollutant are processed by the function emis_post which create street emissions. Then, the function emis_merge merges all the street emissions files from emis_post_ into one street emissions by pollutant ehich is inputted into functionemis_gridto create a polygon grid of emissions, class Spatial Featuresf[@sf], [@RJ-2018-009]. Then, the spatial gridded emissions are inputted into the contructor functionGriddedEmissionsArray` to create an object of that class, and the dimensions of the wrfinput file, that is, the sanem number of spatial rows and columns. Finally, the GriddedEmissionsArray objects are inputted into the wrfchemi file with the eixport function wrf_put. Figure 9.1: Generation of wrfchem inputs using GriddedEmissionsArray Example 9.1.1 Creating a WRF-Chem input file The emission file will be generated with traffic simulation from the Traffic Engineering Company (CET) for 2012, which consists in traffic flow for morning rush hour of Light Duty Vehicles (LDV). The emission factors will be the data fe2015 and the wrfinput comes from the eixport package. Let’s go: 9.1.1.1 0) Network The object net has a class SpatialLinesDataFrame, we transform it into a sfobject. The length of the road is the field ‘lkm’ in the object net, which are in km but has no units. We must add the right units in order to use vein require(vein) require(sf) require(units) net &lt;- readRDS(&quot;figuras/net.rds&quot;) class(net) net &lt;- sf::st_as_sf(net) net[1, ] net$lkm &lt;- units::set_units(st_length(net), km) # ensure right units 9.1.1.2 1) Vehicular composition In this case, the vehicular composition consits in only to vehicles, Passenger Cars using Gasoline with 25% of Ethanol and Light Trucks consuming Diesel with 5% od biodiesel. Also, the emission factors cover \\(CO\\). The temporal distribution will cover only one hour. PC_E25 &lt;- age_ldv(net$ldv) 9.1.1.3 2) Emission factors The emission factors used comes from CETESB (2015), which are constant by age of use. In practice, this data.frame is like an Excel spreadsheet. Then, the constructor function EmissionFactorsList convert our numeric vector, which is the column of our data.frame, into required type of object of the emis function. Parenthesis were added in order to print the objects in one line. data(fe2015) (EF_CO_PC_E25 &lt;- EmissionFactorsList(fe2015[fe2015$Pollutant == &quot;CO&quot;, &quot;PC_G&quot;])) 9.1.1.4 3) Estimation of emissions The estimation of emissions is shown in the following code chunk in a simplified way. The emissions array are aggregated. data(profiles) emi &lt;- emis(veh = PC_E25, lkm = net$lkm, ef = EF_CO_PC_E25, profile = profiles$PC_JUNE_2012) 9.1.1.5 4) Post-estimations The resulting emissions array emi is now processed with emis_post. co_street &lt;- emis_post(arra = emi, by = &quot;streets_wide&quot;, net = net) 9.1.1.5.1 4a WRFChem input file with eixport Now it is time generate the emissions grid. In order to create a wrfchem input file, we need a wrfinput file. In this case, the wrfinput coversa wider area of the emissions, located in São Paulo, Brazil. The wrfinput file is available from the R package eixport. wrf &lt;- paste(system.file(&quot;extdata&quot;, package = &quot;eixport&quot;), &quot;/wrfinput_d02&quot;, sep=&quot;&quot;) g &lt;- make_grid(wrf) ## path to wrfinput ## using grid info from: /home/sergio/R/x86_64-pc-linux-gnu-library/3.5/eixport/extdata/wrfinput_d02 ## Number of lat points 51 ## Number of lon points 63 plot(st_geometry(g), axes = TRUE) plot(st_geometry(co_street), add = TRUE) Notice that weh we create grid from the path to wrfinput, there is a message with Number of lat points 51 and Number of lon points 63. This information is crytical for later conversions. Now that we have the street emissions and the grid, we can obtain our gridded emissions: gCO &lt;- emis_grid(spobj = co_street, g = g) ## Sum of street emissions 1845699895.43 ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Sum of gridded emissions 1845699895.43 names(gCO) ## [1] &quot;id&quot; &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; &quot;V5&quot; ## [7] &quot;V6&quot; &quot;V7&quot; &quot;V8&quot; &quot;V9&quot; &quot;V10&quot; &quot;V11&quot; ## [13] &quot;V12&quot; &quot;V13&quot; &quot;V14&quot; &quot;V15&quot; &quot;V16&quot; &quot;V17&quot; ## [19] &quot;V18&quot; &quot;V19&quot; &quot;V20&quot; &quot;V21&quot; &quot;V22&quot; &quot;V23&quot; ## [25] &quot;V24&quot; &quot;V25&quot; &quot;V26&quot; &quot;V27&quot; &quot;V28&quot; &quot;V29&quot; ## [31] &quot;V30&quot; &quot;V31&quot; &quot;V32&quot; &quot;V33&quot; &quot;V34&quot; &quot;V35&quot; ## [37] &quot;V36&quot; &quot;V37&quot; &quot;V38&quot; &quot;V39&quot; &quot;V40&quot; &quot;V41&quot; ## [43] &quot;V42&quot; &quot;V43&quot; &quot;V44&quot; &quot;V45&quot; &quot;V46&quot; &quot;V47&quot; ## [49] &quot;V48&quot; &quot;V49&quot; &quot;V50&quot; &quot;V51&quot; &quot;V52&quot; &quot;V53&quot; ## [55] &quot;V54&quot; &quot;V55&quot; &quot;V56&quot; &quot;V57&quot; &quot;V58&quot; &quot;V59&quot; ## [61] &quot;V60&quot; &quot;V61&quot; &quot;V62&quot; &quot;V63&quot; &quot;V64&quot; &quot;V65&quot; ## [67] &quot;V66&quot; &quot;V67&quot; &quot;V68&quot; &quot;V69&quot; &quot;V70&quot; &quot;V71&quot; ## [73] &quot;V72&quot; &quot;V73&quot; &quot;V74&quot; &quot;V75&quot; &quot;V76&quot; &quot;V77&quot; ## [79] &quot;V78&quot; &quot;V79&quot; &quot;V80&quot; &quot;V81&quot; &quot;V82&quot; &quot;V83&quot; ## [85] &quot;V84&quot; &quot;V85&quot; &quot;V86&quot; &quot;V87&quot; &quot;V88&quot; &quot;V89&quot; ## [91] &quot;V90&quot; &quot;V91&quot; &quot;V92&quot; &quot;V93&quot; &quot;V94&quot; &quot;V95&quot; ## [97] &quot;V96&quot; &quot;V97&quot; &quot;V98&quot; &quot;V99&quot; &quot;V100&quot; &quot;V101&quot; ## [103] &quot;V102&quot; &quot;V103&quot; &quot;V104&quot; &quot;V105&quot; &quot;V106&quot; &quot;V107&quot; ## [109] &quot;V108&quot; &quot;V109&quot; &quot;V110&quot; &quot;V111&quot; &quot;V112&quot; &quot;V113&quot; ## [115] &quot;V114&quot; &quot;V115&quot; &quot;V116&quot; &quot;V117&quot; &quot;V118&quot; &quot;V119&quot; ## [121] &quot;V120&quot; &quot;V121&quot; &quot;V122&quot; &quot;V123&quot; &quot;V124&quot; &quot;V125&quot; ## [127] &quot;V126&quot; &quot;V127&quot; &quot;V128&quot; &quot;V129&quot; &quot;V130&quot; &quot;V131&quot; ## [133] &quot;V132&quot; &quot;V133&quot; &quot;V134&quot; &quot;V135&quot; &quot;V136&quot; &quot;V137&quot; ## [139] &quot;V138&quot; &quot;V139&quot; &quot;V140&quot; &quot;V141&quot; &quot;V142&quot; &quot;V143&quot; ## [145] &quot;V144&quot; &quot;V145&quot; &quot;V146&quot; &quot;V147&quot; &quot;V148&quot; &quot;V149&quot; ## [151] &quot;V150&quot; &quot;V151&quot; &quot;V152&quot; &quot;V153&quot; &quot;V154&quot; &quot;V155&quot; ## [157] &quot;V156&quot; &quot;V157&quot; &quot;V158&quot; &quot;V159&quot; &quot;V160&quot; &quot;V161&quot; ## [163] &quot;V162&quot; &quot;V163&quot; &quot;V164&quot; &quot;V165&quot; &quot;V166&quot; &quot;V167&quot; ## [169] &quot;V168&quot; &quot;geometry&quot; gCO$geometry ## Geometry set for 3213 features ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -47.43966 ymin: -24.4031 xmax: -45.57575 ymax: -23.00105 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## First 5 geometries: ## POLYGON ((-47.41831 -24.35009, -47.41831 -24.38... ## POLYGON ((-47.38871 -24.35053, -47.38871 -24.38... ## POLYGON ((-47.35907 -24.35097, -47.35907 -24.38... ## POLYGON ((-47.32947 -24.35143, -47.32947 -24.38... ## POLYGON ((-47.29984 -24.35187, -47.29984 -24.38... This function requires the package lwgeom when the data is in latitude and longitude degrees. There are some messages about the total emissions of street and grid. This was made in order to ensure that emis_grid is conservative. The resulting object gCO is an sf object of POLYGON. In order to plot the emissions, i selected the emissions above 1, because it is easier to see the plot. If we plot the gridded emissions, we will see: gCO$V9 &lt;- gCO$V9*(12 + 16)^-1 plot(gCO[gCO$V9 &gt;1, &quot;V9&quot;], axes = TRUE, nbreaks = 50, pal = cptcity::cpt(colorRampPalette = T), main = &quot;Emissions of CO at 08:00 (mol/h)&quot;) Figure 9.2: Gridded emissions (mol/h) The emissions are mostly distributed into main roads, as expected. The next step is create the GriddedEmissionsArray that will be inputted into the eixport functions. The GriddedEmissionsArray is a contructor function that reads class, SpatialPolygonDataFrame, sf of POLYGONs, a data.frame or a matrix to create an Array of the gridded emissions. The dimensions are lat, lon, mass and time. Therefore, it is important to know the number of lat and lon points! gCOA &lt;- GriddedEmissionsArray(x = gCO, cols = 63, rows = 51, times = 168) ## This GriddedEmissionsArray has: ## 51 lat points ## 63 lon points ## 168 hours plot(gCOA, col = cptcity::cpt()) Figure 9.3: GriddedEmissionsArray (mol/h) The image is similar to the plot of the gridded emissions, which means that it is correct. Now we can input the our new created object gCOA into the wrfchem input file, but first, we need to create it. This is done using the eixport functions. We first load the library eixport. Then load the data emis_opt which has the emissions options for WRFchem. In this case, we are creating an wrfchem input file with 40 pollutants, with 0. library(eixport) data(emis_opt) emis_opt[[&quot;ecb05_opt1&quot;]] wrf_create(wrfinput_dir = system.file(&quot;extdata&quot;, package = &quot;eixport&quot;), wrfchemi_dir = tempdir(), frames_per_auxinput5 = 168, domains = 2, variaveis = emis_opt[[&quot;ecb05_opt1&quot;]], verbose = F) The wrfchemi input file was created on a temporal directory with the function tempdir. Now we can input our GriddedEmissionsArray into our new wrfchem input file. f &lt;- list.files(path = tempdir(), full.names = T, pattern = &quot;wrfchemi_d02&quot;) f wrf_put(file = f, name = &quot;E_CO&quot;, POL = gCOA) Then, we just check our resulting NetCDF file plotting the emissions we just put. wrf_plot(f, &quot;E_CO&quot;) Figure 9.4: Wrfchem input file (NetCDF) (mol/h) 9.1.1.5.2 4b WRFChem input file with emis_wrf emis_wrf creates a data.frame with columns lat, long, id, pollutants, local time and GMT time. This dataframe has the proper format to be used with WRF assimilation system: “ASimilation System 4 WRF (AS4WRF, Vara-Vela (2013)) args(emis_wrf) ## function (sdf, nr = 1, dmyhm, tz, crs = 4326, islist, utc) ## NULL where: sdf: Gridded emissions, which can be a SpatialPolygonsDataFrame, or a list of SpatialPolygonsDataFrame, or a sf object of “POLYGON”. The user must enter a list with 36 SpatialPolygonsDataFrame with emissions for the mechanism CBM-Z. nr: Number of repetitions of the emissions period dmyhm: String indicating Day Month Year Hour and Minute in the format “d-m-Y H:M” e.g.: “01-05-2014 00:00” It represents the time of the first hour of emissions in Local Time tz: Time zone as required in for function as.POSIXct crs: Coordinate reference system, e.g: “+init=epsg:4326”. Used to transform the coordinates of the output islist: logical value to indicate if sdf is a list or not utc: ignored. In this case, we can use our gridded emissions directly here: gCO$id &lt;- NULL df &lt;- emis_wrf(sdf = gCO, dmyhm = &quot;06-10-2014 00:00&quot;, tz = &quot;America/Sao_Paulo&quot;, islist = FALSE) ## You can create wrchem inputs directly with ## eixport::create and eixport::wrf_put ## https://CRAN.R-project.org/package=eixport head(df) ## id long lat pollutant time_lt time_utc dutch ## 1 1 -47.41831 -24.35009 0 2014-10-06 2014-10-06 03:00:00 600 ## 6 2 -47.38871 -24.35053 0 2014-10-06 2014-10-06 03:00:00 600 ## 11 3 -47.35907 -24.35097 0 2014-10-06 2014-10-06 03:00:00 600 ## 16 4 -47.32947 -24.35143 0 2014-10-06 2014-10-06 03:00:00 600 ## 21 5 -47.29984 -24.35187 0 2014-10-06 2014-10-06 03:00:00 600 ## 26 6 -47.27024 -24.35230 0 2014-10-06 2014-10-06 03:00:00 600 Then you must export this data.frame into a .txt file. You must include the number of columns to match your luped species and also take out the columns time_lt, time_utc and dutch. These three columns are just informative. df &lt;- df[,1:4] write.table(x = df, file = tempfile(), sep = &quot;\\t&quot;, col.names = TRUE, row.names = FALSE) Finally, in order to generate the wrfchem input file, you must have the resulting .txt file, a wrfinput file with the same grid spacing, the NCL script AS4WRF and a namelist. AS4WRF and the namelist can be obtained contacting angel.vela@iag.usp.br and alvv1986@gmail.com. Appendix B "],
["check.html", "Chapter 10 Quality check and errors 10.1 Guidance from EMEP/EEA air pollutant emission inventory guidebook 10.2 Avoiding errors with VEIN", " Chapter 10 Quality check and errors This last chapter of this book presents to aspestcs fthat must be considered for any practicioner interested in developing emissions inventories. The first part covers a summary of the EMEP/EEA air pollutant emission inventory guidebook 2016, Technical guidance to prepare national emission inventories (McGlade and Vidic 2009), based on the Intergovernmental Panel on Climate Change (IPCC) 2006 Good Practice Guidance [Change (2006). The second part consists in advices and specific considerations for avoinding errors when runnign VEIN in each part of the inventory. 10.1 Guidance from EMEP/EEA air pollutant emission inventory guidebook I believe that this part of this capter delivers knowledge that you really will gain with experience. But even with experience you can get lost, and returning to this part would save you. This part is based on the EMEP/EEA air pollutant emission inventory guidebook (McGlade and Vidic 2009). 10.1.1 Key categories Key categories are the most important source categories. This section is based on the chapter Key category analysis and methodological choice (J 2013) of the EMEP/EEA air pollutant emission inventory guidebook 2013. They are important because they are responsabile for most of pollution in a determined region. For instance, it has been described that vehicles are the most important source of pollution in mega-cities (Molina and Molina 2004). Evenmore, in the case of São Paulo, the official emissions inventory informs that vehicles are responsabiel for mor than 97 % of \\(CO\\), 79 % of \\(HC\\), 68 % of \\(NO_X\\), and only 29 % of \\(PM\\) and 22 % of \\(SO_X\\) (CETESB 2015). This shown another characteristics of key categories: they depend of specific pollutants. For another example, consider a city which suffers cold weather with use bio-mass burning for cooking and heating. The main source of \\(PM_{2.5}\\) will be certainly bio-mass burning. Now consider an industrial region with industrial process that emit too much \\(SO_X\\). The key-cateogries might be industrial sources. And one more example, consider a huge mega-city with electric mobility. However, the main source of electricity are thermoelectric based on carbon (the key). This implies that it should be a nomemclature for categorizing and naming sources. IPCC, has a nomenclature for instance. The ideia behind key categories, is that most efforts must be applied in this categories, obtainging the highest level of detail with less uncertainty. Hence, the emissions guidelines (McGlade and Vidic 2009) proposes three levels of complexity estimation methods, known as Tier Methods. The complexity increases from level 1, 2 and 3. The VEIN tier is 3, which is that the most complex function of vehicular emissions estimations are incporated, with the exception of evaporative. I need to improve that part. Tier 1: a simpler method which include available activity and emissions factors. Tier 2: Similar to Tier 1, but includes more specific emission factors. Tier 3: Most complex methodologies with higher level of detail, temporal and spatial. 10.1.2 Uncertainty This is a very important part in any emissions inventory and a dedicated chapter or section should be made in any report/paper. This section is based on the chapter Uncertainties (Pulles T 2013) of the EMEP/EEA air pollutant emission inventory guidebook 2013.The 2006 IPCC Guidelines chapter states that estimating the uncertainty of an inventory is needed (Change 2006). It is recommended to use 95% confidence interval. This means that: there is a 95% of probability that the actual value of the quantity estimates is within the interval defined by the confidence interval. The probability of the actual value will be outside the range it is 5%. The general form for estimating emissions was shown on Eq. (1.1) (Pulles T 2013). This equation will be the base for calculating the uncertainty. This section is applied when measurements are made, for the case of activity or emission factors. In those case, it is possible calculate the required confiden intervals. 10.1.2.1 Default uncertainty ranges Activity data The following table is taking directly form McGlade and Vidic (2009) and propose indicative ranges that could be applies in cases where no independed data are available. National official statistics: - . Update of last year’s statistics using Gross Economic Growth factors: 0 - 2%. International Energy Agency (IEA) statistics: OECD: 2 - 3%, non-OECD 5-10%. United Nation data bases: 5 - 10%. Default values, other sources: 30 - 100%. Emission factors The following table is taking directly form McGlade and Vidic (2009) and propose rating definitions for emission factors(McGlade and Vidic 2009). A: An estimate based on a large number of measurements made at a large number of facilities that fully represent the sector. Error: 10 o 30%. B: An estimate based on a large number of measurements made at a large number of facilities that represent a large part of the sector. Error: 20 to 60% C: An estimate based on a number of measurements made at a small number of representative facilities, or an engineering judgement based on a number of relevant facts. Error: 50 to 200%. D: An estimate based on single measurements, or an engineering calculation derived from a number of relevant facts. Error: 100 to 300%. E: An estimate based on an engineering calculation derived from assumptions only. Error: Order of magnitude. In McGlade and Vidic (2009) appears ratings for road transport emission factors that diffier from the ratings that appear in Ntziachristos and Samaras (2016). To preserve consistenty in this book, here is presented the precision indicators, Table 4-1 of Ntziachristos and Samaras (2016) report. Table 10.1: Precision indicators (Ntziachristos and Samaras 2016) Category NOx CO NMHC CH4 PM N2O NH3 CO2 PC G w/o Catalyst A A A A - C C A PC G w Catalyst A A A A - A A A PC D A A A A A B B A PC LPG A A A - - - - A PC LPG w/o Catalyst A A A A D C C A PC LPG w Catalyst D D D D D D D A PC 2 strokes B B B D - D D B LCV G B B B C - B B A LCV D B B B C A B B A HDV G D D D C - D D D HDV D A A A D A B B A MC cc &lt;50 A A A B - B B A MC cc &gt; 50 2 strokes A A A B - B B A MC cc &gt; 50 4 strokes A A A B - B B A Cold-start PC G Pre Euro B B B - - - - B Cold-start PC G Euros B B B A - - - A Cold-start PC D Pre Euro C C C - C - - B Cold-start PC D Euros A A A A A - - A Cold-start PC LPG C C C - - - - B Cold-start LCV G D D D - - - - D Cold-start LCV F D D D - D - - D Uncertainties can be aggregated with two approaches Rule A: uncertainties are combined by addition, as shown in Eq. (10.1): \\[\\begin{equation} U_{total}=\\frac{\\sqrt{\\sum_{i = 1}^{n}(U_i \\cdot x_i )^2}}{\\sum_{i = 1}^{n}} \\tag{10.1} \\end{equation}\\] Where, \\(x\\) are the quantities, \\(U_i\\) are the uncertain quantities and the percentage uncertainties (half the 95% confidence interval) associated with them, respectivly. \\(U_{total}\\) is the percentage uncertinti in the sum of the quantites (half the 95% confidence interval divided by the total (i.e. mean) and expressed as percentage). Rule B: uncertainties are combined by multiplication, as shown on Eq. (10.2): \\[\\begin{equation} U_{total}=\\sqrt{\\sum_{i = 1}^{n}(U_i)^2} \\tag{10.2} \\end{equation}\\] Where, \\(U_i\\) are the percentage quantities (hal the 95% confidence interval) associated with each of the quantities. \\(U_{total}\\) is the percentage in the product of the quantities (half the 95% confidence interval divided by the total and expressed as percentage). Alternatively, a Monte Carlo simulation can be done. 10.1.3 Quality Assurance and Quality Check This section is mostly based on the chapter Inventory management, improvement and QA/QC (Goodwin et al. 2013) of the EMEP/EEA air pollutant emission inventory guidebook 2013. According to Wikipedia: Quality assurance (QA) is a way of preventing mistakes and defects in manufactured products and avoiding problems when delivering solutions or services to customers (Wikipedia contributors 2018b). Quality control (QC) is a process by which entities review the quality of all factors involved in production (Wikipedia contributors 2018c). The main reference in QA/QC are the International Organization for Standardization ISO 9000 (Wikipedia contributors 2018a). The idea is to avoid errors in the development of the inventory. Hence, it is very important that the objective of the inventory, frequency and spatial and temporal resolution must be very clear. As mentioned before, the inventory can have a purpose of policy application or scientific. In any case, the QAQC procedures should be explicitly stated covering five data quality objectives transparency, consistency, comparability, completeness and acccuracy. This means that another researcher/practicioner should be able to reproduce the results. However, this is not always the case. Evenmore, it has been shown that there are currently a crisis of reproducibility in science, where ‘more than 70% of researchers have tried and failed to reproduce another scientist’s experiments, and more than half have failed to reproduce their own experiments’ (Baker 2016). I believe that emissions inventories should guarantee the reproducibility of results, in scientific and policy application inventories. 10.1.4 Inventory managment cycle Another important aspect is the inventory managment cycle. The inventory manager is responsabile for institutional arrangments, meet deadlines and for the inventory managment cycle. The inventory complier gets the data and estimate the emissions with the respective Tier. The cycle is: Priorization of improvements: As the resources are limited, priorization must be given to key categories. Data-collection: It is important to stablish formal agreements needs with data providers using protocols. The protocols must cleary show the data needed, its format, content and dates of delivery. Inventory compilation. The inventory compiler estimate the emissions. Consolidation. The inventory manager consolidates all the emissions ensuring quality in data and methods for estimating emissions. Data Quality Review. Reporting. Lessons learned and improvement review. Inventory Managment Report. Quality Assurance and Quality Control Plan. 10.2 Avoiding errors with VEIN The first part of this chapter covered some fundamental aspects in emissions inventory managment for quality assurance and quality control. This part covers typical erros that I’ve faced using VEIN and I hope it help users how to avoid them. Currently, VEIN does not have grafical user interface (GUI) and runs on R (R Core Team 2017), which can be intimidating for new users. Also, even experienced users can do mistakes. If you find a mistake, write it down to abooid it in future. Be organized. I recommend to code your inventory keeping in mind that you will have to check your scripts in the future, so it would be nice if in the first try your code looks nice. And also, don’t panic. 10.2.1 Traffic flow One of the first inputs of it is the traffic flow data. You must have an agreement with data providers to get the data. Also, the compiler must understand the format of the data. In my experience, data providers comes from government agencies with limitated resources and few time. This means that, if there is not a formal agreement, they won’t speed too much time for processing their data to meet your needs (because it is not part of their jobs). And even, if there was a formal agreement, the data processing must be done by the data compiler. The data provided in this book covers a travel demand output for Metropolitan Are ofSão Paulo (MASP) made by the Traffic Company Engineering of São Paulo, for the year 2012. The has the same content inside VEIN package, with the exception that covers the whole MASP. The data originally is in format MAPINFO. Therefore, the package sf must be used to read the data. library(sf) net &lt;- st_read(&quot;data/masp.TAB&quot;) The section @ref(#traffic) shows details about this data. Have a meeting with data delivers to check and solve any doubt regarding the data. Check if your data is projected or not. The data probably will be projected with a UTM zone, for instance code 31983 http://spatialreference.org/ref/epsg/sirgas-2000-utm-zone-23s/. VEIN imports functions from sf and lwgeom which depend on GEOS libraries. This means that VEIN can work with data projected or not. Nevertheless, I suggest to work with projected data for your location. Ensure that the data is correctly read and that there are no objects of class factor in the columns. Make sure that of what are the units of the traffic flow and remember that most of VEIN functions are designed to work with hourly traffic flow. Plot the data. Check if the data looks fine or have some mistakes. Calculate the length of each road. Make proper transformations and make sure that resulting length of road as units km. I suggest to use the name lkm. This can be easily done with in R with packages sf and units installed. Let’s say that your data is named net and your data is already projected. Also, that your traffic flow is named ldv for light duty vehicles and hdv for heavy duty vehicles. plot(net[&quot;ldv&quot;], axes = T) plot(net[&quot;hdv&quot;], axes = T) net$lkm &lt;- sf::st_length(net) #returns distance in meters net$$lkm &lt;- units::set_units(net$lkm, km) #transform meters in km Despite that this transformation can be done by dividing lkm by 1000, this would be wrong because the units wouldn’t change and they must be km. Hence, using the functions of the units package is the recommended way. 10.2.2 Vehicular composition The vehicular composition is a critical part in the emissions inventories for vehicles. It consists in the percentage of each type of vehicle and technology. Despite that it seems pretty straightforward, making a mistake in this part of the emissions inventories would cost lots of time. Developing an emissions inventory is a complex task, you must take great care in simple calculations, because if the resutls are not consistent, it can take LOTS of time, to find the error, usually when the dealines are dead. The function inventory needs the vehicular composition to create the respective directories to run VEIN. I have the feeling that most of model users like structured models with clear input and outputs. VEIN is not like that, and this is in part due to the nature of the emissions inventories. I could design a model that works perfectly with one type of input, but in real life, a desired input is not always easy to get. For instance, the traffic simulation used inside the model is not easy to get, even in cities of developed countries. Hence, the inventory compiler must struggle to do their job. Therefore, VEIN was designed with flexibility and verstility on mind. Anyways, the vehicular composition are the number of each type the following vehicles: PC, LCV, HGB, BUS, MC. Then, each sub category will be divided by type of age of use. For instance, the vehicular emissions inventory for São Paulo State considers 4 type of vehicles: Particulate Cars using gasohol (Gasoline with 25% of ethanol, PC_25). Particulate Cars Flex using gasohol (Gasoline with 25% of ethanol, PC_F25). Particulate Cars Flex using ethanol (Gasoline with 25% of ethanol, PC_FE100). Particulate Cars using ethanol (Gasoline with 25% of ethanol, PC_E100). This means that the number of PC is 4. Then each of this vehicles is divided by age of use. As consecuence, we must know when each of these vehicle entered and went out of the market. Again, for São Paulo conditions, Flex engines entered into market in 2003 and nowadays must of new cars are flex. Vehicles with engines designed for burning ethanol had a peak in early 80s, but they went of the market in 2006. Gasoline vehicles have been in circulation from the beginning and CETESB inventory considers a life span of 40 years of use. The same analyses must be done with each of the vehicle categories. The distribution by age of use indirectly shows the technology associated with emission standards by age of use. 10.2.3 Units Currently, VEIN checks that the variable lkm (length) must be in km. This is to avoid that the user wrongly enter length in meters or without units. As a result, the emissions woult be huge and wrong. In the case of vehicles, currently there are not designed a unit of “vehicles” in VEIN. In transportation studies, it is used the unit “equivalent vehicle” which standarize each type of vehicle by its size. For instance, LCV are sometimes equivalent of 1.2 vehicles. Buses or HGV can be equuvalent to 2 or more vehicles. however, there are no such typeof this things in VEIN and units managment is designed to control emission factors and length. The temporal dimension is also an aspect difficult to handle regarding the units. This is because, sometimes mileage are correctly in km, but the timespan is in one year. Threfore, the units magament is degined to avoid errors with emission factors and calculation of emissions. This means that a future version of VEIN will erradicate all temporal dimensions ensure right calculation of mass only. This means that VEIN will not chech if the data is hourly or anunual. 10.2.4 Emission factors When I started this book, VEIN contained few emission factors. Now, the version 0.5.4 has all the 2016 emission factors of CETESB, almost 100 emisision factors from the European Emission guidelines the all the BASE emission factors from the International Vehicle Model (IVE). The functions to access this data are: ef_cetesb. ef_ldv_speed. ef_hdv_speed. ef_ive. I will be working to import emission factors from HBEFA model which are based traffic situation (very cool). 10.2.5 Deterioration VEIN currently cover the deterioration emission factors from the Euroepan emission guidelines. This values results in a simply numeric vector depending on standard, mileage, type of vehicle and pollutant. However, it would be possible to use any other deterioation factors. Ensure to use correctly the data and cite respective literature. 10.2.6 Fuel evaluation It is a good practice to ensure that the mass of fuel consumed of vehicle in your study area, matchs the fuel sale son your area. If not, calibrate your emissions by number of vehicles (if bottom-up) or a combination of vehicles and mileage (if top-down) to match fuel sales. 10.2.7 Emissions estimation Most of emission functions returns an array of emissions, which means a matrix of matrices. The idea was that each dimension has a meaning but I’ve been thinking that it is not necessary and each dimension should have different nature, for instance, it is not necessary two dimensions for time, despite that one indicates hour and the other days. So I mght change that in future. Dont panic, I’m always trying to change the functions without breaking older code. I hope you liked this book. Appendix B "],
["references.html", "References", " References "],
["appendix-a-fast-example-of-vein.html", "Appendix A: Fast Example of VEIN", " Appendix A: Fast Example of VEIN library(vein) inventory(name = file.path(tempdir(), &quot;YourCity&quot;), show.dir = TRUE, show.scripts = TRUE) source(paste0(file.path(tempdir(), &quot;YourCity&quot;), &quot;main.R&quot;)) "],
["appendix-b-detailed-example-of-vein.html", "Appendix B: Detailed Example of VEIN A.3 Network A.4 Vehicular composition (CETESB 2015) A.5 Traffic data", " Appendix B: Detailed Example of VEIN A.3 Network inventory(file.path(tempdir(), &quot;YourCity&quot;)) setwd(&quot;YourCity&quot;) data(net) # Loads the traffic demand simulation for west São Paulo data(net) data(pc_profile) pc_week &lt;- temp_fact(net$ldv+net$hdv, pc_profile) speed &lt;- netspeed(pc_week, net$ps, net$ffs, net$capacity, net$lkm) saveRDS(net, file = &quot;network/net.rds&quot;) saveRDS(speed, file = &quot;network/speed.rds&quot;) A.4 Vehicular composition (CETESB 2015) The vehicular composition vehcomp has 5 types of vehicles: Passenger Carss (PC), Light Commercial Vehicles (LCV), Heavy Good Vehicles or trucks (HGV), Buses (BUS), and Motorcycles (MC). The default value of this argument is: c(PC = 4, LCV = 5, HGV = 5, BUS = 3, MC = 9), which means that there are 4 types of PC, 5 of LCV, 5 of trucks, 3 of buses and 9 types of motorcycles. This composition comes from the vehicular emissions inventory of the Environmental Agency of São Paulo, Brazil (CETESB 2015). In Brazil, the fuel used in vehicles is blended with ethanol with and biodiesel. The user can use any vehicular composition that representes its fleet with up-to 99 type of vehicles per category. The default composition according Brazilian emissions inventory is: Passenger Cars (PC) Passenger Cars using Gasoline blended with 25% of ethanol (E25). Passenger Cars with Flex engine using Gasoline blended with 25% of ethanol (FE25). Passenger Cars with Flex engine using 100% of ethanol (FE100). Passenger Cars with engines that uses only ethanol (E100). Light Commercial Vehicles (LCV) Light Commercial Vehicles with gross weight (GW) less than 3.8 t using Gasoline blended with 25% of ethanol (E25). Light Commercial Vehicles with GW less than 3.8 t with Flex engine using Gasoline blended with 25% of ethanol (FE25). Light Commercial Vehicles with GW less than 3.8 t with Flex engine using 100% of ethanol (FE100). Light Commercial Vehicles with GW less than 3.8 t with engines that uses only ethanol (E100). Light Commercial Vehicles with GW less than 3.8 t with engines that uses only ethanol (E100). Heavy Good Vehicles (HGV) or Trucks Semi Light Trucks (SLT) with 3.8 t &lt; GW &lt; 6 t using Diesel blended with 5% of biodiesel (B5). Light Trucks (LT) with 6 t &lt; GW &lt; 10 t using Diesel blended with 5% of biodiesel (B5). Medium Trucks (MT) with 10 t &lt; GW &lt; 15 t using Diesel blended with 5% of biodiesel (B5). Semi Heavy Trucks (SHT) with 15 t &lt; GW on a Rigid Truck (RT) and GW &lt; 40 on an Articulated Truck (AT) using Diesel blended with 5% of bodiesel (B5). Heavy Trucks (HT) with 15 t &lt; GW on a RT and GW &gt;= 40 on an AT using Diesel blended with 5% of bodiesel (B5). Buses Urban Bus (UB) using Diesel blended with 5% of biodiesel (B5). Small Urban Bus (SUB) using Diesel blended with 5% of biodiesel (B5). Motorway Bus (MB) or Coach using Diesel blended with 5% of biodiesel (B5). Motorcycles (MC) Motorcycles with engine cc &lt; 150 using Gasoline blended with 25% of ethanol (E25). Motorcycles with engine 150 &lt; cc &lt; 500 using Gasoline blended with 25% of ethanol (E25). Motorcycles with engine cc &gt; 500 using Gasoline blended with 25% of ethanol (E25). Motorcycles with engine cc &lt; 150 with Flex engine using Gasoline blended with 25% of ethanol (FE25). Motorcycles with engine 150 &lt; cc &lt; 500 with Flex engine using Gasoline blended with 25% of ethanol (FE25). Motorcycles with engine cc &gt; 500 with Flex engine using Gasoline blended with 25% of ethanol (FE25). Motorcycles with engine cc &lt; 150 with Flex engine using 100% of ethanol (FE100). Motorcycles with engine 150 &lt; cc &lt; 500 with Flex engine using 100% of ethanol (FE100). Motorcycles with engine cc &gt; 500 with Flex engine using 100% of ethanol (FE100). A.5 Traffic data The vehicular composition will split the traffic simulation as shown on next table. The simulation has traffic for Light Duty Vehicles and Heavy Good Vehicles, therefore, the vehicular composition must split this categories and considerations: Passenger Cars (PC) = 75% of Light Duty Vehicles (LDV) of traffic simulation. Light Commercial Vehicles (LCV) = 10% of LDV of traffic simulation. Motorcycles (MC) = 15% of LDV on traffic simulation. Heavy Good Vehicles (HGV) = 75% of Heavy Duty Vehicles (HDV). Buses = = 25% of Heavy Duty Vehicles (HDV). LCV and PC have vehicles with flex engines capable to run with any mixture of gasoline and ethanol (Giroldo et al. 2005). Type of fuel consumed consists in gasoline blended with 25% of ethanol (E25). The vehicular composition consists in type of vehicles and type of fuel. Optionally, the user could have a wider vehicular composition considering more sizes, gross weight, etc. The percentages in composition apply for each type of vehicle PC, LCV, HGV, BUS and MC. Passenger Cars The vehicular composition consisted in PC using E25, PC with Flex engines using E25 and E100, and OC with engines for consuming only E100. The PC with Flex engines entered into Brazilian market in 2003, therefore, at year 2015 flex vehicles has 13 years of use. On the other case, PC with engines for E100 went out of the market in 2007, therefore, the newest PC with E100 engine has 9 years of use. Table 10.2: Vehicular composition of PC for applied in this book Vehicles Composition PC_E25 37.25% PC_FE25 22.26% PC_FE100 37.97% PC_E100 2.44% PC_E25 &lt;- age_ldv(x = net$ldv,name = &quot;PC_E25&quot;, k = 75/100*37.25) PC_FE25 &lt;- age_ldv(x = net$ldv, name = &quot;PC_FE25&quot;, agemax = 13, k = 75/100*22.26) PC_FE100 &lt;- age_ldv(x = net$ldv, name = &quot;PC_FE100&quot;, agemax = 13, k = 75/100*37.97) PC_E100 &lt;- age_ldv(x = net$ldv, name = &quot;PC_E100&quot;, agemin = 9, k = 75/100*2.44) saveRDS(PC_E25, file = &quot;veh/PC_E25.rds&quot;) saveRDS(PC_FE25, file = &quot;veh/PC_FE25.rds&quot;) saveRDS(PC_FE100, file = &quot;veh/PC_FE100.rds&quot;) saveRDS(PC_E100, file = &quot;veh/PC_E100.rds&quot;) Light Commercial Vehicles The engine/fuel type affects in the same way to LCV with PC vehicles. However, this category has a fraction of vehicles being driven with diesel. In Brazil, all diesle is blended with approximatly 5% of biodiesel, then it is named as B5. The categorization of the names in LCV is similar with PC. Table 10.3: Vehicular composition of LCV for applied in this book Vehicles Composition LCV_E25 39.13% LCV_FE25 15.21% LCV_FE100 25.90% LCV_E100 1.18% LCV_B5 18.58% LCV_E25 &lt;- age_ldv(x = net$ldv,name = &quot;LCV_E25&quot;, k = 10/100*39.13) LCV_FE25 &lt;- age_ldv(x = net$ldv, name = &quot;LCV_FE25&quot;, agemax = 13, k = 10/100*15.21) LCV_FE100 &lt;- age_ldv(x = net$ldv, name = &quot;LCV_FE100&quot;, agemax = 13, k = 10/100*25.90) LCV_E100 &lt;- age_ldv(x = net$ldv, name = &quot;LCV_E100&quot;, agemin = 9, k = 10/100*1.18) LCV_B5 &lt;- age_ldv(x = net$ldv, name = &quot;LCV_B5&quot;, k = 10/100*18.58) saveRDS(LCV_E25, file = &quot;veh/LCV_E25.rds&quot;) saveRDS(LCV_FE25, file = &quot;veh/LCV_FE25.rds&quot;) saveRDS(LCV_FE100, file = &quot;veh/LCV_FE100.rds&quot;) saveRDS(LCV_E100, file = &quot;veh/LCV_E100.rds&quot;) saveRDS(LCV_B5, file = &quot;veh/LCV_B5.rds&quot;) Heavy Good Vehicles HGV uses diesel which is blended with approximatly 5% of biodiesel from sugar- cane. Table 10.4: Vehicular composition of HGV for applied in this book Vehicles Composition SLT 8.38% LT 25.50% MT 15.28% SHT 24.98% HT 25.85% HGV_SLT_B5 &lt;- age_hdv(x = net$hdv,name = &quot;HGV_SLT_B5&quot;, k = 75/100*8.38) HGV_LT_B5 &lt;- age_hdv(x = net$hdv, name = &quot;HGV_SLT_B5&quot;, k = 75/100*25.50) HGV_MT_B5 &lt;- age_hdv(x = net$hdv, name = &quot;HGV_SLT_B5&quot;, k = 75/100*15.28) HGV_SHT_B5 &lt;- age_hdv(x = net$hdv, name = &quot;HGV_SLT_B5&quot;, k = 75/100*24.98) HGV_HT_B5 &lt;- age_hdv(x = net$hdv, name = &quot;HGV_SLT_B5&quot;, k = 75/100*25.85) saveRDS(HGV_LT_B5, file = &quot;veh/HGV_SLT_B5.rds&quot;) saveRDS(HGV_SLT_B5, file = &quot;veh/HGV_LT_B5.rds&quot;) saveRDS(HGV_MT_B5, file = &quot;veh/HGV_MT_B5.rds&quot;) saveRDS(HGV_SHT_B5, file = &quot;veh/HGV_SHT_B5.rds&quot;) saveRDS(HGV_HT_B5, file = &quot;veh/HGV_HT_B5.rds&quot;) Buses In Brazil there are many type of buses, but in this book we are focussing in the most abundandt: Urban Buses, Small Urban Buses and Motoreway Buses ro Coach. According to the Secretary or Urban Mobility of São Paulo (Sptrans, http://www.sptrans.com.br/), the fleet has an average age of use of 5 years and 5 monthts. To achieve this average age, the agemax of this vehicles is 10 years of use. Table 10.5: Vehicular composition of BUS for applied in this book Vehicles Composition UB 77.43% SUB 9.07% MB 13.5% UB_B5 &lt;- age_hdv(x = net$ldv,name = &quot;UB_B5&quot;, agemax = 10, k = 25/100*77.43) SUB_B5 &lt;- age_hdv(x = net$ldv, name = &quot;SUB_B5&quot;, k = 25/100*9.07) MB_B5 &lt;- age_hdv(x = net$ldv, name = &quot;MB_B5&quot;, k = 25/100*13.5) saveRDS(HGV_LT_B5, file = &quot;veh/HGV_SLT_B5.rds&quot;) saveRDS(HGV_SLT_B5, file = &quot;veh/HGV_LT_B5.rds&quot;) saveRDS(HGV_MT_B5, file = &quot;veh/HGV_MT_B5.rds&quot;) Motorcycles The vehicular composition consisted in Motorcycles using E25, and recnetly, in year 2010, entered into the market flex motorcycles, which can use gasoline E25 or ethano E100. Therefore, the oldest flex MC is 6 years old. Table 10.6: Vehicular composition of MC for applied in this book Vehicles Composition MC_150_E25 72.97% MC_150_500_E25 11.28% MC_500_E25 3.15% MC_150_FE25 3.93% MC_150_500_FE25 0.57% MC_500_FE25 0.16% MC_150_FE100 6.69% MC_150_500_FE100 0.98% MC_500_FE100 0.27% MC_150_E25 &lt;- age_hdv(x = net$ldv,name = &quot;MC_150_E25&quot;, k = 15/100*72.97) MC_150_500_E25 &lt;- age_hdv(x = net$ldv, name = &quot;MC_150_500_E25&quot;, k = 15/100*11.28) MC_500_E25 &lt;- age_hdv(x = net$ldv, name = &quot;MC_500_E25&quot;, k = 15/100*3.15) MC_150_FE25 &lt;- age_hdv(x = net$ldv,name = &quot;MC_150_FE25&quot;, agemax = 6, k = 15/100*3.93) MC_150_500_FE25 &lt;- age_hdv(x = net$ldv, name = &quot;MC_150_500_FE25&quot;, agemax = 6, k = 15/100*0.57) MC_500_FE25 &lt;- age_hdv(x = net$ldv, name = &quot;MC_500_FE25&quot;, agemax = 6, k = 15/100*0.16) MC_150_FE100 &lt;- age_hdv(x = net$ldv,name = &quot;MC_150_FE100&quot;, agemax = 6, k = 15/100*6.69) MC_150_500_FE100 &lt;- age_hdv(x = net$ldv, name = &quot;MC_150_500_FE100&quot;, agemax = 6, k = 15/100*0.98) MC_500_FE100 &lt;- age_hdv(x = net$ldv, name = &quot;MC_500_FE100&quot;, agemax = 6, k = 15/100*0.27) saveRDS(MC_150_E25, file = &quot;veh/MC_150_E25.rds&quot;) saveRDS(MC_150_500_E25, file = &quot;veh/MC_150_500_E25.rds&quot;) saveRDS(MC_500_E25, file = &quot;veh/MC_500_E25.rds&quot;) saveRDS(MC_150_FE25, file = &quot;veh/MC_150_FE25.rds&quot;) saveRDS(MC_150_500_FE25, file = &quot;veh/MC_150_500_FE25.rds&quot;) saveRDS(MC_500_FE25, file = &quot;veh/MC_500_FE25.rds&quot;) saveRDS(MC_150_FE100, file = &quot;veh/MC_150_FE100.rds&quot;) saveRDS(MC_150_500_FE100, file = &quot;veh/MC_150_500_FE100.rds&quot;) saveRDS(MC_500_FE100, file = &quot;veh/MC_500_FE100.rds&quot;) Appendix B "],
["appendix-b.html", "Appendix B", " Appendix B "]
]
